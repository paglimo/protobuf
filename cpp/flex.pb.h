// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: flex.proto
// Protobuf C++ Version: 5.29.2

#ifndef flex_2eproto_2epb_2eh
#define flex_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_flex_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_flex_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_flex_2eproto;
namespace flex {
class BeeRemoteNode;
struct BeeRemoteNodeDefaultTypeInternal;
extern BeeRemoteNodeDefaultTypeInternal _BeeRemoteNode_default_instance_;
class BulkUpdateWorkRequest;
struct BulkUpdateWorkRequestDefaultTypeInternal;
extern BulkUpdateWorkRequestDefaultTypeInternal _BulkUpdateWorkRequest_default_instance_;
class BulkUpdateWorkResponse;
struct BulkUpdateWorkResponseDefaultTypeInternal;
extern BulkUpdateWorkResponseDefaultTypeInternal _BulkUpdateWorkResponse_default_instance_;
class HeartbeatRequest;
struct HeartbeatRequestDefaultTypeInternal;
extern HeartbeatRequestDefaultTypeInternal _HeartbeatRequest_default_instance_;
class HeartbeatResponse;
struct HeartbeatResponseDefaultTypeInternal;
extern HeartbeatResponseDefaultTypeInternal _HeartbeatResponse_default_instance_;
class MockJob;
struct MockJobDefaultTypeInternal;
extern MockJobDefaultTypeInternal _MockJob_default_instance_;
class NodeStats;
struct NodeStatsDefaultTypeInternal;
extern NodeStatsDefaultTypeInternal _NodeStats_default_instance_;
class RemoteStorageTarget;
struct RemoteStorageTargetDefaultTypeInternal;
extern RemoteStorageTargetDefaultTypeInternal _RemoteStorageTarget_default_instance_;
class RemoteStorageTarget_Azure;
struct RemoteStorageTarget_AzureDefaultTypeInternal;
extern RemoteStorageTarget_AzureDefaultTypeInternal _RemoteStorageTarget_Azure_default_instance_;
class RemoteStorageTarget_POSIX;
struct RemoteStorageTarget_POSIXDefaultTypeInternal;
extern RemoteStorageTarget_POSIXDefaultTypeInternal _RemoteStorageTarget_POSIX_default_instance_;
class RemoteStorageTarget_Policies;
struct RemoteStorageTarget_PoliciesDefaultTypeInternal;
extern RemoteStorageTarget_PoliciesDefaultTypeInternal _RemoteStorageTarget_Policies_default_instance_;
class RemoteStorageTarget_S3;
struct RemoteStorageTarget_S3DefaultTypeInternal;
extern RemoteStorageTarget_S3DefaultTypeInternal _RemoteStorageTarget_S3_default_instance_;
class SubmitWorkRequest;
struct SubmitWorkRequestDefaultTypeInternal;
extern SubmitWorkRequestDefaultTypeInternal _SubmitWorkRequest_default_instance_;
class SubmitWorkResponse;
struct SubmitWorkResponseDefaultTypeInternal;
extern SubmitWorkResponseDefaultTypeInternal _SubmitWorkResponse_default_instance_;
class SyncJob;
struct SyncJobDefaultTypeInternal;
extern SyncJobDefaultTypeInternal _SyncJob_default_instance_;
class UpdateConfigRequest;
struct UpdateConfigRequestDefaultTypeInternal;
extern UpdateConfigRequestDefaultTypeInternal _UpdateConfigRequest_default_instance_;
class UpdateConfigResponse;
struct UpdateConfigResponseDefaultTypeInternal;
extern UpdateConfigResponseDefaultTypeInternal _UpdateConfigResponse_default_instance_;
class UpdateWorkRequest;
struct UpdateWorkRequestDefaultTypeInternal;
extern UpdateWorkRequestDefaultTypeInternal _UpdateWorkRequest_default_instance_;
class UpdateWorkResponse;
struct UpdateWorkResponseDefaultTypeInternal;
extern UpdateWorkResponseDefaultTypeInternal _UpdateWorkResponse_default_instance_;
class Work;
struct WorkDefaultTypeInternal;
extern WorkDefaultTypeInternal _Work_default_instance_;
class WorkRequest;
struct WorkRequestDefaultTypeInternal;
extern WorkRequestDefaultTypeInternal _WorkRequest_default_instance_;
class WorkRequest_Segment;
struct WorkRequest_SegmentDefaultTypeInternal;
extern WorkRequest_SegmentDefaultTypeInternal _WorkRequest_Segment_default_instance_;
class Work_Part;
struct Work_PartDefaultTypeInternal;
extern Work_PartDefaultTypeInternal _Work_Part_default_instance_;
class Work_Status;
struct Work_StatusDefaultTypeInternal;
extern Work_StatusDefaultTypeInternal _Work_Status_default_instance_;
}  // namespace flex
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace flex {
enum UpdateWorkRequest_NewState : int {
  UpdateWorkRequest_NewState_UNSPECIFIED = 0,
  UpdateWorkRequest_NewState_CANCELLED = 1,
  UpdateWorkRequest_NewState_UpdateWorkRequest_NewState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UpdateWorkRequest_NewState_UpdateWorkRequest_NewState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UpdateWorkRequest_NewState_IsValid(int value);
extern const uint32_t UpdateWorkRequest_NewState_internal_data_[];
constexpr UpdateWorkRequest_NewState UpdateWorkRequest_NewState_NewState_MIN = static_cast<UpdateWorkRequest_NewState>(0);
constexpr UpdateWorkRequest_NewState UpdateWorkRequest_NewState_NewState_MAX = static_cast<UpdateWorkRequest_NewState>(1);
constexpr int UpdateWorkRequest_NewState_NewState_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
UpdateWorkRequest_NewState_descriptor();
template <typename T>
const std::string& UpdateWorkRequest_NewState_Name(T value) {
  static_assert(std::is_same<T, UpdateWorkRequest_NewState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NewState_Name().");
  return UpdateWorkRequest_NewState_Name(static_cast<UpdateWorkRequest_NewState>(value));
}
template <>
inline const std::string& UpdateWorkRequest_NewState_Name(UpdateWorkRequest_NewState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UpdateWorkRequest_NewState_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool UpdateWorkRequest_NewState_Parse(absl::string_view name, UpdateWorkRequest_NewState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UpdateWorkRequest_NewState>(
      UpdateWorkRequest_NewState_descriptor(), name, value);
}
enum BulkUpdateWorkRequest_NewState : int {
  BulkUpdateWorkRequest_NewState_UNSPECIFIED = 0,
  BulkUpdateWorkRequest_NewState_UNCHANGED = 1,
  BulkUpdateWorkRequest_NewState_BulkUpdateWorkRequest_NewState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  BulkUpdateWorkRequest_NewState_BulkUpdateWorkRequest_NewState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool BulkUpdateWorkRequest_NewState_IsValid(int value);
extern const uint32_t BulkUpdateWorkRequest_NewState_internal_data_[];
constexpr BulkUpdateWorkRequest_NewState BulkUpdateWorkRequest_NewState_NewState_MIN = static_cast<BulkUpdateWorkRequest_NewState>(0);
constexpr BulkUpdateWorkRequest_NewState BulkUpdateWorkRequest_NewState_NewState_MAX = static_cast<BulkUpdateWorkRequest_NewState>(1);
constexpr int BulkUpdateWorkRequest_NewState_NewState_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
BulkUpdateWorkRequest_NewState_descriptor();
template <typename T>
const std::string& BulkUpdateWorkRequest_NewState_Name(T value) {
  static_assert(std::is_same<T, BulkUpdateWorkRequest_NewState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NewState_Name().");
  return BulkUpdateWorkRequest_NewState_Name(static_cast<BulkUpdateWorkRequest_NewState>(value));
}
template <>
inline const std::string& BulkUpdateWorkRequest_NewState_Name(BulkUpdateWorkRequest_NewState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BulkUpdateWorkRequest_NewState_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool BulkUpdateWorkRequest_NewState_Parse(absl::string_view name, BulkUpdateWorkRequest_NewState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BulkUpdateWorkRequest_NewState>(
      BulkUpdateWorkRequest_NewState_descriptor(), name, value);
}
enum SyncJob_Operation : int {
  SyncJob_Operation_UNSPECIFIED = 0,
  SyncJob_Operation_UPLOAD = 1,
  SyncJob_Operation_DOWNLOAD = 2,
  SyncJob_Operation_SyncJob_Operation_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SyncJob_Operation_SyncJob_Operation_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SyncJob_Operation_IsValid(int value);
extern const uint32_t SyncJob_Operation_internal_data_[];
constexpr SyncJob_Operation SyncJob_Operation_Operation_MIN = static_cast<SyncJob_Operation>(0);
constexpr SyncJob_Operation SyncJob_Operation_Operation_MAX = static_cast<SyncJob_Operation>(2);
constexpr int SyncJob_Operation_Operation_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
SyncJob_Operation_descriptor();
template <typename T>
const std::string& SyncJob_Operation_Name(T value) {
  static_assert(std::is_same<T, SyncJob_Operation>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Operation_Name().");
  return SyncJob_Operation_Name(static_cast<SyncJob_Operation>(value));
}
template <>
inline const std::string& SyncJob_Operation_Name(SyncJob_Operation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SyncJob_Operation_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SyncJob_Operation_Parse(absl::string_view name, SyncJob_Operation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SyncJob_Operation>(
      SyncJob_Operation_descriptor(), name, value);
}
enum Work_State : int {
  Work_State_UNSPECIFIED = 0,
  Work_State_UNKNOWN = 1,
  Work_State_CREATED = 2,
  Work_State_SCHEDULED = 3,
  Work_State_RUNNING = 4,
  Work_State_ERROR = 6,
  Work_State_FAILED = 7,
  Work_State_CANCELLED = 8,
  Work_State_COMPLETED = 9,
  Work_State_Work_State_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Work_State_Work_State_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Work_State_IsValid(int value);
extern const uint32_t Work_State_internal_data_[];
constexpr Work_State Work_State_State_MIN = static_cast<Work_State>(0);
constexpr Work_State Work_State_State_MAX = static_cast<Work_State>(9);
constexpr int Work_State_State_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor*
Work_State_descriptor();
template <typename T>
const std::string& Work_State_Name(T value) {
  static_assert(std::is_same<T, Work_State>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to State_Name().");
  return Work_State_Name(static_cast<Work_State>(value));
}
template <>
inline const std::string& Work_State_Name(Work_State value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Work_State_descriptor,
                                                 0, 9>(
      static_cast<int>(value));
}
inline bool Work_State_Parse(absl::string_view name, Work_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Work_State>(
      Work_State_descriptor(), name, value);
}
enum UpdateConfigResponse_Result : int {
  UpdateConfigResponse_Result_UNSPECIFIED = 0,
  UpdateConfigResponse_Result_SUCCESS = 1,
  UpdateConfigResponse_Result_PARTIAL = 2,
  UpdateConfigResponse_Result_FAILURE = 3,
  UpdateConfigResponse_Result_UpdateConfigResponse_Result_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UpdateConfigResponse_Result_UpdateConfigResponse_Result_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UpdateConfigResponse_Result_IsValid(int value);
extern const uint32_t UpdateConfigResponse_Result_internal_data_[];
constexpr UpdateConfigResponse_Result UpdateConfigResponse_Result_Result_MIN = static_cast<UpdateConfigResponse_Result>(0);
constexpr UpdateConfigResponse_Result UpdateConfigResponse_Result_Result_MAX = static_cast<UpdateConfigResponse_Result>(3);
constexpr int UpdateConfigResponse_Result_Result_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
UpdateConfigResponse_Result_descriptor();
template <typename T>
const std::string& UpdateConfigResponse_Result_Name(T value) {
  static_assert(std::is_same<T, UpdateConfigResponse_Result>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Result_Name().");
  return UpdateConfigResponse_Result_Name(static_cast<UpdateConfigResponse_Result>(value));
}
template <>
inline const std::string& UpdateConfigResponse_Result_Name(UpdateConfigResponse_Result value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UpdateConfigResponse_Result_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool UpdateConfigResponse_Result_Parse(absl::string_view name, UpdateConfigResponse_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UpdateConfigResponse_Result>(
      UpdateConfigResponse_Result_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class WorkRequest_Segment final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.WorkRequest.Segment) */ {
 public:
  inline WorkRequest_Segment() : WorkRequest_Segment(nullptr) {}
  ~WorkRequest_Segment() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(WorkRequest_Segment* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(WorkRequest_Segment));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WorkRequest_Segment(
      ::google::protobuf::internal::ConstantInitialized);

  inline WorkRequest_Segment(const WorkRequest_Segment& from) : WorkRequest_Segment(nullptr, from) {}
  inline WorkRequest_Segment(WorkRequest_Segment&& from) noexcept
      : WorkRequest_Segment(nullptr, std::move(from)) {}
  inline WorkRequest_Segment& operator=(const WorkRequest_Segment& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkRequest_Segment& operator=(WorkRequest_Segment&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkRequest_Segment& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkRequest_Segment* internal_default_instance() {
    return reinterpret_cast<const WorkRequest_Segment*>(
        &_WorkRequest_Segment_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(WorkRequest_Segment& a, WorkRequest_Segment& b) { a.Swap(&b); }
  inline void Swap(WorkRequest_Segment* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkRequest_Segment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkRequest_Segment* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<WorkRequest_Segment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorkRequest_Segment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WorkRequest_Segment& from) { WorkRequest_Segment::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(WorkRequest_Segment* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.WorkRequest.Segment"; }

 protected:
  explicit WorkRequest_Segment(::google::protobuf::Arena* arena);
  WorkRequest_Segment(::google::protobuf::Arena* arena, const WorkRequest_Segment& from);
  WorkRequest_Segment(::google::protobuf::Arena* arena, WorkRequest_Segment&& from) noexcept
      : WorkRequest_Segment(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOffsetStartFieldNumber = 1,
    kOffsetStopFieldNumber = 2,
    kPartsStartFieldNumber = 3,
    kPartsStopFieldNumber = 4,
  };
  // int64 offset_start = 1;
  void clear_offset_start() ;
  ::int64_t offset_start() const;
  void set_offset_start(::int64_t value);

  private:
  ::int64_t _internal_offset_start() const;
  void _internal_set_offset_start(::int64_t value);

  public:
  // int64 offset_stop = 2;
  void clear_offset_stop() ;
  ::int64_t offset_stop() const;
  void set_offset_stop(::int64_t value);

  private:
  ::int64_t _internal_offset_stop() const;
  void _internal_set_offset_stop(::int64_t value);

  public:
  // int32 parts_start = 3;
  void clear_parts_start() ;
  ::int32_t parts_start() const;
  void set_parts_start(::int32_t value);

  private:
  ::int32_t _internal_parts_start() const;
  void _internal_set_parts_start(::int32_t value);

  public:
  // int32 parts_stop = 4;
  void clear_parts_stop() ;
  ::int32_t parts_stop() const;
  void set_parts_stop(::int32_t value);

  private:
  ::int32_t _internal_parts_stop() const;
  void _internal_set_parts_stop(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:flex.WorkRequest.Segment)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const WorkRequest_Segment& from_msg);
    ::int64_t offset_start_;
    ::int64_t offset_stop_;
    ::int32_t parts_start_;
    ::int32_t parts_stop_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class Work_Status final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.Work.Status) */ {
 public:
  inline Work_Status() : Work_Status(nullptr) {}
  ~Work_Status() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Work_Status* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Work_Status));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Work_Status(
      ::google::protobuf::internal::ConstantInitialized);

  inline Work_Status(const Work_Status& from) : Work_Status(nullptr, from) {}
  inline Work_Status(Work_Status&& from) noexcept
      : Work_Status(nullptr, std::move(from)) {}
  inline Work_Status& operator=(const Work_Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Work_Status& operator=(Work_Status&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Work_Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Work_Status* internal_default_instance() {
    return reinterpret_cast<const Work_Status*>(
        &_Work_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(Work_Status& a, Work_Status& b) { a.Swap(&b); }
  inline void Swap(Work_Status* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Work_Status* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Work_Status* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Work_Status>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Work_Status& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Work_Status& from) { Work_Status::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Work_Status* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.Work.Status"; }

 protected:
  explicit Work_Status(::google::protobuf::Arena* arena);
  Work_Status(::google::protobuf::Arena* arena, const Work_Status& from);
  Work_Status(::google::protobuf::Arena* arena, Work_Status&& from) noexcept
      : Work_Status(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 2,
    kStateFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .flex.Work.State state = 1;
  void clear_state() ;
  ::flex::Work_State state() const;
  void set_state(::flex::Work_State value);

  private:
  ::flex::Work_State _internal_state() const;
  void _internal_set_state(::flex::Work_State value);

  public:
  // @@protoc_insertion_point(class_scope:flex.Work.Status)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      32, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Work_Status& from_msg);
    ::google::protobuf::internal::ArenaStringPtr message_;
    int state_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class Work_Part final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.Work.Part) */ {
 public:
  inline Work_Part() : Work_Part(nullptr) {}
  ~Work_Part() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Work_Part* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Work_Part));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Work_Part(
      ::google::protobuf::internal::ConstantInitialized);

  inline Work_Part(const Work_Part& from) : Work_Part(nullptr, from) {}
  inline Work_Part(Work_Part&& from) noexcept
      : Work_Part(nullptr, std::move(from)) {}
  inline Work_Part& operator=(const Work_Part& from) {
    CopyFrom(from);
    return *this;
  }
  inline Work_Part& operator=(Work_Part&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Work_Part& default_instance() {
    return *internal_default_instance();
  }
  static inline const Work_Part* internal_default_instance() {
    return reinterpret_cast<const Work_Part*>(
        &_Work_Part_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(Work_Part& a, Work_Part& b) { a.Swap(&b); }
  inline void Swap(Work_Part* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Work_Part* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Work_Part* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Work_Part>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Work_Part& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Work_Part& from) { Work_Part::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Work_Part* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.Work.Part"; }

 protected:
  explicit Work_Part(::google::protobuf::Arena* arena);
  Work_Part(::google::protobuf::Arena* arena, const Work_Part& from);
  Work_Part(::google::protobuf::Arena* arena, Work_Part&& from) noexcept
      : Work_Part(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityTagFieldNumber = 4,
    kChecksumSha256FieldNumber = 5,
    kOffsetStartFieldNumber = 2,
    kOffsetStopFieldNumber = 3,
    kPartNumberFieldNumber = 1,
    kCompletedFieldNumber = 6,
  };
  // string entity_tag = 4;
  void clear_entity_tag() ;
  const std::string& entity_tag() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entity_tag(Arg_&& arg, Args_... args);
  std::string* mutable_entity_tag();
  PROTOBUF_NODISCARD std::string* release_entity_tag();
  void set_allocated_entity_tag(std::string* value);

  private:
  const std::string& _internal_entity_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity_tag(
      const std::string& value);
  std::string* _internal_mutable_entity_tag();

  public:
  // string checksum_sha256 = 5;
  void clear_checksum_sha256() ;
  const std::string& checksum_sha256() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_checksum_sha256(Arg_&& arg, Args_... args);
  std::string* mutable_checksum_sha256();
  PROTOBUF_NODISCARD std::string* release_checksum_sha256();
  void set_allocated_checksum_sha256(std::string* value);

  private:
  const std::string& _internal_checksum_sha256() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_checksum_sha256(
      const std::string& value);
  std::string* _internal_mutable_checksum_sha256();

  public:
  // int64 offset_start = 2;
  void clear_offset_start() ;
  ::int64_t offset_start() const;
  void set_offset_start(::int64_t value);

  private:
  ::int64_t _internal_offset_start() const;
  void _internal_set_offset_start(::int64_t value);

  public:
  // int64 offset_stop = 3;
  void clear_offset_stop() ;
  ::int64_t offset_stop() const;
  void set_offset_stop(::int64_t value);

  private:
  ::int64_t _internal_offset_stop() const;
  void _internal_set_offset_stop(::int64_t value);

  public:
  // int32 part_number = 1;
  void clear_part_number() ;
  ::int32_t part_number() const;
  void set_part_number(::int32_t value);

  private:
  ::int32_t _internal_part_number() const;
  void _internal_set_part_number(::int32_t value);

  public:
  // bool completed = 6;
  void clear_completed() ;
  bool completed() const;
  void set_completed(bool value);

  private:
  bool _internal_completed() const;
  void _internal_set_completed(bool value);

  public:
  // @@protoc_insertion_point(class_scope:flex.Work.Part)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      48, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Work_Part& from_msg);
    ::google::protobuf::internal::ArenaStringPtr entity_tag_;
    ::google::protobuf::internal::ArenaStringPtr checksum_sha256_;
    ::int64_t offset_start_;
    ::int64_t offset_stop_;
    ::int32_t part_number_;
    bool completed_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class UpdateWorkRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.UpdateWorkRequest) */ {
 public:
  inline UpdateWorkRequest() : UpdateWorkRequest(nullptr) {}
  ~UpdateWorkRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateWorkRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateWorkRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateWorkRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateWorkRequest(const UpdateWorkRequest& from) : UpdateWorkRequest(nullptr, from) {}
  inline UpdateWorkRequest(UpdateWorkRequest&& from) noexcept
      : UpdateWorkRequest(nullptr, std::move(from)) {}
  inline UpdateWorkRequest& operator=(const UpdateWorkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateWorkRequest& operator=(UpdateWorkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateWorkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateWorkRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateWorkRequest*>(
        &_UpdateWorkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(UpdateWorkRequest& a, UpdateWorkRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateWorkRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateWorkRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateWorkRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateWorkRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateWorkRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateWorkRequest& from) { UpdateWorkRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateWorkRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.UpdateWorkRequest"; }

 protected:
  explicit UpdateWorkRequest(::google::protobuf::Arena* arena);
  UpdateWorkRequest(::google::protobuf::Arena* arena, const UpdateWorkRequest& from);
  UpdateWorkRequest(::google::protobuf::Arena* arena, UpdateWorkRequest&& from) noexcept
      : UpdateWorkRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using NewState = UpdateWorkRequest_NewState;
  static constexpr NewState UNSPECIFIED = UpdateWorkRequest_NewState_UNSPECIFIED;
  static constexpr NewState CANCELLED = UpdateWorkRequest_NewState_CANCELLED;
  static inline bool NewState_IsValid(int value) {
    return UpdateWorkRequest_NewState_IsValid(value);
  }
  static constexpr NewState NewState_MIN = UpdateWorkRequest_NewState_NewState_MIN;
  static constexpr NewState NewState_MAX = UpdateWorkRequest_NewState_NewState_MAX;
  static constexpr int NewState_ARRAYSIZE = UpdateWorkRequest_NewState_NewState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* NewState_descriptor() {
    return UpdateWorkRequest_NewState_descriptor();
  }
  template <typename T>
  static inline const std::string& NewState_Name(T value) {
    return UpdateWorkRequest_NewState_Name(value);
  }
  static inline bool NewState_Parse(absl::string_view name, NewState* value) {
    return UpdateWorkRequest_NewState_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kJobIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
    kNewStateFieldNumber = 3,
  };
  // string job_id = 1;
  void clear_job_id() ;
  const std::string& job_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_job_id(Arg_&& arg, Args_... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* value);

  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(
      const std::string& value);
  std::string* _internal_mutable_job_id();

  public:
  // string request_id = 2;
  void clear_request_id() ;
  const std::string& request_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_request_id(Arg_&& arg, Args_... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* value);

  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(
      const std::string& value);
  std::string* _internal_mutable_request_id();

  public:
  // .flex.UpdateWorkRequest.NewState new_state = 3;
  void clear_new_state() ;
  ::flex::UpdateWorkRequest_NewState new_state() const;
  void set_new_state(::flex::UpdateWorkRequest_NewState value);

  private:
  ::flex::UpdateWorkRequest_NewState _internal_new_state() const;
  void _internal_set_new_state(::flex::UpdateWorkRequest_NewState value);

  public:
  // @@protoc_insertion_point(class_scope:flex.UpdateWorkRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      47, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateWorkRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr job_id_;
    ::google::protobuf::internal::ArenaStringPtr request_id_;
    int new_state_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class UpdateConfigResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.UpdateConfigResponse) */ {
 public:
  inline UpdateConfigResponse() : UpdateConfigResponse(nullptr) {}
  ~UpdateConfigResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateConfigResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateConfigResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateConfigResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateConfigResponse(const UpdateConfigResponse& from) : UpdateConfigResponse(nullptr, from) {}
  inline UpdateConfigResponse(UpdateConfigResponse&& from) noexcept
      : UpdateConfigResponse(nullptr, std::move(from)) {}
  inline UpdateConfigResponse& operator=(const UpdateConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateConfigResponse& operator=(UpdateConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateConfigResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateConfigResponse*>(
        &_UpdateConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(UpdateConfigResponse& a, UpdateConfigResponse& b) { a.Swap(&b); }
  inline void Swap(UpdateConfigResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateConfigResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateConfigResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateConfigResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateConfigResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateConfigResponse& from) { UpdateConfigResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateConfigResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.UpdateConfigResponse"; }

 protected:
  explicit UpdateConfigResponse(::google::protobuf::Arena* arena);
  UpdateConfigResponse(::google::protobuf::Arena* arena, const UpdateConfigResponse& from);
  UpdateConfigResponse(::google::protobuf::Arena* arena, UpdateConfigResponse&& from) noexcept
      : UpdateConfigResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Result = UpdateConfigResponse_Result;
  static constexpr Result UNSPECIFIED = UpdateConfigResponse_Result_UNSPECIFIED;
  static constexpr Result SUCCESS = UpdateConfigResponse_Result_SUCCESS;
  static constexpr Result PARTIAL = UpdateConfigResponse_Result_PARTIAL;
  static constexpr Result FAILURE = UpdateConfigResponse_Result_FAILURE;
  static inline bool Result_IsValid(int value) {
    return UpdateConfigResponse_Result_IsValid(value);
  }
  static constexpr Result Result_MIN = UpdateConfigResponse_Result_Result_MIN;
  static constexpr Result Result_MAX = UpdateConfigResponse_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE = UpdateConfigResponse_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Result_descriptor() {
    return UpdateConfigResponse_Result_descriptor();
  }
  template <typename T>
  static inline const std::string& Result_Name(T value) {
    return UpdateConfigResponse_Result_Name(value);
  }
  static inline bool Result_Parse(absl::string_view name, Result* value) {
    return UpdateConfigResponse_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .flex.UpdateConfigResponse.Result result = 1;
  void clear_result() ;
  ::flex::UpdateConfigResponse_Result result() const;
  void set_result(::flex::UpdateConfigResponse_Result value);

  private:
  ::flex::UpdateConfigResponse_Result _internal_result() const;
  void _internal_set_result(::flex::UpdateConfigResponse_Result value);

  public:
  // @@protoc_insertion_point(class_scope:flex.UpdateConfigResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      41, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateConfigResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr message_;
    int result_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class SyncJob final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.SyncJob) */ {
 public:
  inline SyncJob() : SyncJob(nullptr) {}
  ~SyncJob() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SyncJob* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SyncJob));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SyncJob(
      ::google::protobuf::internal::ConstantInitialized);

  inline SyncJob(const SyncJob& from) : SyncJob(nullptr, from) {}
  inline SyncJob(SyncJob&& from) noexcept
      : SyncJob(nullptr, std::move(from)) {}
  inline SyncJob& operator=(const SyncJob& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncJob& operator=(SyncJob&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncJob& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncJob* internal_default_instance() {
    return reinterpret_cast<const SyncJob*>(
        &_SyncJob_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(SyncJob& a, SyncJob& b) { a.Swap(&b); }
  inline void Swap(SyncJob* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncJob* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncJob* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SyncJob>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SyncJob& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SyncJob& from) { SyncJob::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SyncJob* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.SyncJob"; }

 protected:
  explicit SyncJob(::google::protobuf::Arena* arena);
  SyncJob(::google::protobuf::Arena* arena, const SyncJob& from);
  SyncJob(::google::protobuf::Arena* arena, SyncJob&& from) noexcept
      : SyncJob(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Operation = SyncJob_Operation;
  static constexpr Operation UNSPECIFIED = SyncJob_Operation_UNSPECIFIED;
  static constexpr Operation UPLOAD = SyncJob_Operation_UPLOAD;
  static constexpr Operation DOWNLOAD = SyncJob_Operation_DOWNLOAD;
  static inline bool Operation_IsValid(int value) {
    return SyncJob_Operation_IsValid(value);
  }
  static constexpr Operation Operation_MIN = SyncJob_Operation_Operation_MIN;
  static constexpr Operation Operation_MAX = SyncJob_Operation_Operation_MAX;
  static constexpr int Operation_ARRAYSIZE = SyncJob_Operation_Operation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Operation_descriptor() {
    return SyncJob_Operation_descriptor();
  }
  template <typename T>
  static inline const std::string& Operation_Name(T value) {
    return SyncJob_Operation_Name(value);
  }
  static inline bool Operation_Parse(absl::string_view name, Operation* value) {
    return SyncJob_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kRemotePathFieldNumber = 3,
    kOperationFieldNumber = 1,
    kOverwriteFieldNumber = 2,
    kFlattenFieldNumber = 5,
  };
  // string remote_path = 3;
  void clear_remote_path() ;
  const std::string& remote_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_remote_path(Arg_&& arg, Args_... args);
  std::string* mutable_remote_path();
  PROTOBUF_NODISCARD std::string* release_remote_path();
  void set_allocated_remote_path(std::string* value);

  private:
  const std::string& _internal_remote_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_path(
      const std::string& value);
  std::string* _internal_mutable_remote_path();

  public:
  // .flex.SyncJob.Operation operation = 1;
  void clear_operation() ;
  ::flex::SyncJob_Operation operation() const;
  void set_operation(::flex::SyncJob_Operation value);

  private:
  ::flex::SyncJob_Operation _internal_operation() const;
  void _internal_set_operation(::flex::SyncJob_Operation value);

  public:
  // bool overwrite = 2;
  void clear_overwrite() ;
  bool overwrite() const;
  void set_overwrite(bool value);

  private:
  bool _internal_overwrite() const;
  void _internal_set_overwrite(bool value);

  public:
  // bool flatten = 5;
  void clear_flatten() ;
  bool flatten() const;
  void set_flatten(bool value);

  private:
  bool _internal_flatten() const;
  void _internal_set_flatten(bool value);

  public:
  // @@protoc_insertion_point(class_scope:flex.SyncJob)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 4, 0,
      32, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SyncJob& from_msg);
    ::google::protobuf::internal::ArenaStringPtr remote_path_;
    int operation_;
    bool overwrite_;
    bool flatten_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class RemoteStorageTarget_S3 final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.RemoteStorageTarget.S3) */ {
 public:
  inline RemoteStorageTarget_S3() : RemoteStorageTarget_S3(nullptr) {}
  ~RemoteStorageTarget_S3() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RemoteStorageTarget_S3* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RemoteStorageTarget_S3));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RemoteStorageTarget_S3(
      ::google::protobuf::internal::ConstantInitialized);

  inline RemoteStorageTarget_S3(const RemoteStorageTarget_S3& from) : RemoteStorageTarget_S3(nullptr, from) {}
  inline RemoteStorageTarget_S3(RemoteStorageTarget_S3&& from) noexcept
      : RemoteStorageTarget_S3(nullptr, std::move(from)) {}
  inline RemoteStorageTarget_S3& operator=(const RemoteStorageTarget_S3& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteStorageTarget_S3& operator=(RemoteStorageTarget_S3&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteStorageTarget_S3& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteStorageTarget_S3* internal_default_instance() {
    return reinterpret_cast<const RemoteStorageTarget_S3*>(
        &_RemoteStorageTarget_S3_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(RemoteStorageTarget_S3& a, RemoteStorageTarget_S3& b) { a.Swap(&b); }
  inline void Swap(RemoteStorageTarget_S3* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteStorageTarget_S3* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteStorageTarget_S3* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RemoteStorageTarget_S3>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RemoteStorageTarget_S3& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RemoteStorageTarget_S3& from) { RemoteStorageTarget_S3::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RemoteStorageTarget_S3* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.RemoteStorageTarget.S3"; }

 protected:
  explicit RemoteStorageTarget_S3(::google::protobuf::Arena* arena);
  RemoteStorageTarget_S3(::google::protobuf::Arena* arena, const RemoteStorageTarget_S3& from);
  RemoteStorageTarget_S3(::google::protobuf::Arena* arena, RemoteStorageTarget_S3&& from) noexcept
      : RemoteStorageTarget_S3(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEndpointUrlFieldNumber = 1,
    kPartitionIdFieldNumber = 2,
    kRegionFieldNumber = 3,
    kBucketFieldNumber = 4,
    kAccessKeyFieldNumber = 5,
    kSecretKeyFieldNumber = 6,
  };
  // string endpoint_url = 1;
  void clear_endpoint_url() ;
  const std::string& endpoint_url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_endpoint_url(Arg_&& arg, Args_... args);
  std::string* mutable_endpoint_url();
  PROTOBUF_NODISCARD std::string* release_endpoint_url();
  void set_allocated_endpoint_url(std::string* value);

  private:
  const std::string& _internal_endpoint_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endpoint_url(
      const std::string& value);
  std::string* _internal_mutable_endpoint_url();

  public:
  // string partition_id = 2;
  void clear_partition_id() ;
  const std::string& partition_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_partition_id(Arg_&& arg, Args_... args);
  std::string* mutable_partition_id();
  PROTOBUF_NODISCARD std::string* release_partition_id();
  void set_allocated_partition_id(std::string* value);

  private:
  const std::string& _internal_partition_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partition_id(
      const std::string& value);
  std::string* _internal_mutable_partition_id();

  public:
  // string region = 3;
  void clear_region() ;
  const std::string& region() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_region(Arg_&& arg, Args_... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* value);

  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(
      const std::string& value);
  std::string* _internal_mutable_region();

  public:
  // string bucket = 4;
  void clear_bucket() ;
  const std::string& bucket() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bucket(Arg_&& arg, Args_... args);
  std::string* mutable_bucket();
  PROTOBUF_NODISCARD std::string* release_bucket();
  void set_allocated_bucket(std::string* value);

  private:
  const std::string& _internal_bucket() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bucket(
      const std::string& value);
  std::string* _internal_mutable_bucket();

  public:
  // string access_key = 5;
  void clear_access_key() ;
  const std::string& access_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_access_key(Arg_&& arg, Args_... args);
  std::string* mutable_access_key();
  PROTOBUF_NODISCARD std::string* release_access_key();
  void set_allocated_access_key(std::string* value);

  private:
  const std::string& _internal_access_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_key(
      const std::string& value);
  std::string* _internal_mutable_access_key();

  public:
  // string secret_key = 6;
  void clear_secret_key() ;
  const std::string& secret_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secret_key(Arg_&& arg, Args_... args);
  std::string* mutable_secret_key();
  PROTOBUF_NODISCARD std::string* release_secret_key();
  void set_allocated_secret_key(std::string* value);

  private:
  const std::string& _internal_secret_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret_key(
      const std::string& value);
  std::string* _internal_mutable_secret_key();

  public:
  // @@protoc_insertion_point(class_scope:flex.RemoteStorageTarget.S3)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      92, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RemoteStorageTarget_S3& from_msg);
    ::google::protobuf::internal::ArenaStringPtr endpoint_url_;
    ::google::protobuf::internal::ArenaStringPtr partition_id_;
    ::google::protobuf::internal::ArenaStringPtr region_;
    ::google::protobuf::internal::ArenaStringPtr bucket_;
    ::google::protobuf::internal::ArenaStringPtr access_key_;
    ::google::protobuf::internal::ArenaStringPtr secret_key_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class RemoteStorageTarget_Policies final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.RemoteStorageTarget.Policies) */ {
 public:
  inline RemoteStorageTarget_Policies() : RemoteStorageTarget_Policies(nullptr) {}
  ~RemoteStorageTarget_Policies() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RemoteStorageTarget_Policies* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RemoteStorageTarget_Policies));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RemoteStorageTarget_Policies(
      ::google::protobuf::internal::ConstantInitialized);

  inline RemoteStorageTarget_Policies(const RemoteStorageTarget_Policies& from) : RemoteStorageTarget_Policies(nullptr, from) {}
  inline RemoteStorageTarget_Policies(RemoteStorageTarget_Policies&& from) noexcept
      : RemoteStorageTarget_Policies(nullptr, std::move(from)) {}
  inline RemoteStorageTarget_Policies& operator=(const RemoteStorageTarget_Policies& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteStorageTarget_Policies& operator=(RemoteStorageTarget_Policies&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteStorageTarget_Policies& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteStorageTarget_Policies* internal_default_instance() {
    return reinterpret_cast<const RemoteStorageTarget_Policies*>(
        &_RemoteStorageTarget_Policies_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(RemoteStorageTarget_Policies& a, RemoteStorageTarget_Policies& b) { a.Swap(&b); }
  inline void Swap(RemoteStorageTarget_Policies* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteStorageTarget_Policies* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteStorageTarget_Policies* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RemoteStorageTarget_Policies>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RemoteStorageTarget_Policies& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RemoteStorageTarget_Policies& from) { RemoteStorageTarget_Policies::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RemoteStorageTarget_Policies* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.RemoteStorageTarget.Policies"; }

 protected:
  explicit RemoteStorageTarget_Policies(::google::protobuf::Arena* arena);
  RemoteStorageTarget_Policies(::google::protobuf::Arena* arena, const RemoteStorageTarget_Policies& from);
  RemoteStorageTarget_Policies(::google::protobuf::Arena* arena, RemoteStorageTarget_Policies&& from) noexcept
      : RemoteStorageTarget_Policies(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFastStartMaxSizeFieldNumber = 1,
  };
  // int64 fast_start_max_size = 1;
  void clear_fast_start_max_size() ;
  ::int64_t fast_start_max_size() const;
  void set_fast_start_max_size(::int64_t value);

  private:
  ::int64_t _internal_fast_start_max_size() const;
  void _internal_set_fast_start_max_size(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:flex.RemoteStorageTarget.Policies)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RemoteStorageTarget_Policies& from_msg);
    ::int64_t fast_start_max_size_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class RemoteStorageTarget_POSIX final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.RemoteStorageTarget.POSIX) */ {
 public:
  inline RemoteStorageTarget_POSIX() : RemoteStorageTarget_POSIX(nullptr) {}
  ~RemoteStorageTarget_POSIX() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RemoteStorageTarget_POSIX* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RemoteStorageTarget_POSIX));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RemoteStorageTarget_POSIX(
      ::google::protobuf::internal::ConstantInitialized);

  inline RemoteStorageTarget_POSIX(const RemoteStorageTarget_POSIX& from) : RemoteStorageTarget_POSIX(nullptr, from) {}
  inline RemoteStorageTarget_POSIX(RemoteStorageTarget_POSIX&& from) noexcept
      : RemoteStorageTarget_POSIX(nullptr, std::move(from)) {}
  inline RemoteStorageTarget_POSIX& operator=(const RemoteStorageTarget_POSIX& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteStorageTarget_POSIX& operator=(RemoteStorageTarget_POSIX&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteStorageTarget_POSIX& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteStorageTarget_POSIX* internal_default_instance() {
    return reinterpret_cast<const RemoteStorageTarget_POSIX*>(
        &_RemoteStorageTarget_POSIX_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(RemoteStorageTarget_POSIX& a, RemoteStorageTarget_POSIX& b) { a.Swap(&b); }
  inline void Swap(RemoteStorageTarget_POSIX* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteStorageTarget_POSIX* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteStorageTarget_POSIX* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RemoteStorageTarget_POSIX>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RemoteStorageTarget_POSIX& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RemoteStorageTarget_POSIX& from) { RemoteStorageTarget_POSIX::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RemoteStorageTarget_POSIX* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.RemoteStorageTarget.POSIX"; }

 protected:
  explicit RemoteStorageTarget_POSIX(::google::protobuf::Arena* arena);
  RemoteStorageTarget_POSIX(::google::protobuf::Arena* arena, const RemoteStorageTarget_POSIX& from);
  RemoteStorageTarget_POSIX(::google::protobuf::Arena* arena, RemoteStorageTarget_POSIX&& from) noexcept
      : RemoteStorageTarget_POSIX(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // @@protoc_insertion_point(class_scope:flex.RemoteStorageTarget.POSIX)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      43, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RemoteStorageTarget_POSIX& from_msg);
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class MockJob final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.MockJob) */ {
 public:
  inline MockJob() : MockJob(nullptr) {}
  ~MockJob() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MockJob* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MockJob));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MockJob(
      ::google::protobuf::internal::ConstantInitialized);

  inline MockJob(const MockJob& from) : MockJob(nullptr, from) {}
  inline MockJob(MockJob&& from) noexcept
      : MockJob(nullptr, std::move(from)) {}
  inline MockJob& operator=(const MockJob& from) {
    CopyFrom(from);
    return *this;
  }
  inline MockJob& operator=(MockJob&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MockJob& default_instance() {
    return *internal_default_instance();
  }
  static inline const MockJob* internal_default_instance() {
    return reinterpret_cast<const MockJob*>(
        &_MockJob_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(MockJob& a, MockJob& b) { a.Swap(&b); }
  inline void Swap(MockJob* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MockJob* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MockJob* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MockJob>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MockJob& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MockJob& from) { MockJob::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MockJob* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.MockJob"; }

 protected:
  explicit MockJob(::google::protobuf::Arena* arena);
  MockJob(::google::protobuf::Arena* arena, const MockJob& from);
  MockJob(::google::protobuf::Arena* arena, MockJob&& from) noexcept
      : MockJob(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExternalIdFieldNumber = 3,
    kFileSizeFieldNumber = 2,
    kNumTestSegmentsFieldNumber = 1,
    kShouldFailFieldNumber = 4,
    kCanRetryFieldNumber = 5,
  };
  // string external_id = 3;
  void clear_external_id() ;
  const std::string& external_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_external_id(Arg_&& arg, Args_... args);
  std::string* mutable_external_id();
  PROTOBUF_NODISCARD std::string* release_external_id();
  void set_allocated_external_id(std::string* value);

  private:
  const std::string& _internal_external_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_external_id(
      const std::string& value);
  std::string* _internal_mutable_external_id();

  public:
  // int64 file_size = 2;
  void clear_file_size() ;
  ::int64_t file_size() const;
  void set_file_size(::int64_t value);

  private:
  ::int64_t _internal_file_size() const;
  void _internal_set_file_size(::int64_t value);

  public:
  // int32 num_test_segments = 1;
  void clear_num_test_segments() ;
  ::int32_t num_test_segments() const;
  void set_num_test_segments(::int32_t value);

  private:
  ::int32_t _internal_num_test_segments() const;
  void _internal_set_num_test_segments(::int32_t value);

  public:
  // bool should_fail = 4;
  void clear_should_fail() ;
  bool should_fail() const;
  void set_should_fail(bool value);

  private:
  bool _internal_should_fail() const;
  void _internal_set_should_fail(bool value);

  public:
  // bool can_retry = 5;
  void clear_can_retry() ;
  bool can_retry() const;
  void set_can_retry(bool value);

  private:
  bool _internal_can_retry() const;
  void _internal_set_can_retry(bool value);

  public:
  // @@protoc_insertion_point(class_scope:flex.MockJob)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      32, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MockJob& from_msg);
    ::google::protobuf::internal::ArenaStringPtr external_id_;
    ::int64_t file_size_;
    ::int32_t num_test_segments_;
    bool should_fail_;
    bool can_retry_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.HeartbeatRequest) */ {
 public:
  inline HeartbeatRequest() : HeartbeatRequest(nullptr) {}
  ~HeartbeatRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HeartbeatRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HeartbeatRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HeartbeatRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline HeartbeatRequest(const HeartbeatRequest& from) : HeartbeatRequest(nullptr, from) {}
  inline HeartbeatRequest(HeartbeatRequest&& from) noexcept
      : HeartbeatRequest(nullptr, std::move(from)) {}
  inline HeartbeatRequest& operator=(const HeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatRequest& operator=(HeartbeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartbeatRequest*>(
        &_HeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(HeartbeatRequest& a, HeartbeatRequest& b) { a.Swap(&b); }
  inline void Swap(HeartbeatRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HeartbeatRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeartbeatRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HeartbeatRequest& from) { HeartbeatRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HeartbeatRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.HeartbeatRequest"; }

 protected:
  explicit HeartbeatRequest(::google::protobuf::Arena* arena);
  HeartbeatRequest(::google::protobuf::Arena* arena, const HeartbeatRequest& from);
  HeartbeatRequest(::google::protobuf::Arena* arena, HeartbeatRequest&& from) noexcept
      : HeartbeatRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIncludeStatsFieldNumber = 1,
  };
  // bool include_stats = 1;
  void clear_include_stats() ;
  bool include_stats() const;
  void set_include_stats(bool value);

  private:
  bool _internal_include_stats() const;
  void _internal_set_include_stats(bool value);

  public:
  // @@protoc_insertion_point(class_scope:flex.HeartbeatRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HeartbeatRequest& from_msg);
    bool include_stats_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class BulkUpdateWorkResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.BulkUpdateWorkResponse) */ {
 public:
  inline BulkUpdateWorkResponse() : BulkUpdateWorkResponse(nullptr) {}
  ~BulkUpdateWorkResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BulkUpdateWorkResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BulkUpdateWorkResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BulkUpdateWorkResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline BulkUpdateWorkResponse(const BulkUpdateWorkResponse& from) : BulkUpdateWorkResponse(nullptr, from) {}
  inline BulkUpdateWorkResponse(BulkUpdateWorkResponse&& from) noexcept
      : BulkUpdateWorkResponse(nullptr, std::move(from)) {}
  inline BulkUpdateWorkResponse& operator=(const BulkUpdateWorkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BulkUpdateWorkResponse& operator=(BulkUpdateWorkResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BulkUpdateWorkResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BulkUpdateWorkResponse* internal_default_instance() {
    return reinterpret_cast<const BulkUpdateWorkResponse*>(
        &_BulkUpdateWorkResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(BulkUpdateWorkResponse& a, BulkUpdateWorkResponse& b) { a.Swap(&b); }
  inline void Swap(BulkUpdateWorkResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BulkUpdateWorkResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BulkUpdateWorkResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BulkUpdateWorkResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BulkUpdateWorkResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BulkUpdateWorkResponse& from) { BulkUpdateWorkResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BulkUpdateWorkResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.BulkUpdateWorkResponse"; }

 protected:
  explicit BulkUpdateWorkResponse(::google::protobuf::Arena* arena);
  BulkUpdateWorkResponse(::google::protobuf::Arena* arena, const BulkUpdateWorkResponse& from);
  BulkUpdateWorkResponse(::google::protobuf::Arena* arena, BulkUpdateWorkResponse&& from) noexcept
      : BulkUpdateWorkResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:flex.BulkUpdateWorkResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      43, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BulkUpdateWorkResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class BulkUpdateWorkRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.BulkUpdateWorkRequest) */ {
 public:
  inline BulkUpdateWorkRequest() : BulkUpdateWorkRequest(nullptr) {}
  ~BulkUpdateWorkRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BulkUpdateWorkRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BulkUpdateWorkRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BulkUpdateWorkRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline BulkUpdateWorkRequest(const BulkUpdateWorkRequest& from) : BulkUpdateWorkRequest(nullptr, from) {}
  inline BulkUpdateWorkRequest(BulkUpdateWorkRequest&& from) noexcept
      : BulkUpdateWorkRequest(nullptr, std::move(from)) {}
  inline BulkUpdateWorkRequest& operator=(const BulkUpdateWorkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BulkUpdateWorkRequest& operator=(BulkUpdateWorkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BulkUpdateWorkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BulkUpdateWorkRequest* internal_default_instance() {
    return reinterpret_cast<const BulkUpdateWorkRequest*>(
        &_BulkUpdateWorkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(BulkUpdateWorkRequest& a, BulkUpdateWorkRequest& b) { a.Swap(&b); }
  inline void Swap(BulkUpdateWorkRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BulkUpdateWorkRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BulkUpdateWorkRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BulkUpdateWorkRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BulkUpdateWorkRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BulkUpdateWorkRequest& from) { BulkUpdateWorkRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BulkUpdateWorkRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.BulkUpdateWorkRequest"; }

 protected:
  explicit BulkUpdateWorkRequest(::google::protobuf::Arena* arena);
  BulkUpdateWorkRequest(::google::protobuf::Arena* arena, const BulkUpdateWorkRequest& from);
  BulkUpdateWorkRequest(::google::protobuf::Arena* arena, BulkUpdateWorkRequest&& from) noexcept
      : BulkUpdateWorkRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using NewState = BulkUpdateWorkRequest_NewState;
  static constexpr NewState UNSPECIFIED = BulkUpdateWorkRequest_NewState_UNSPECIFIED;
  static constexpr NewState UNCHANGED = BulkUpdateWorkRequest_NewState_UNCHANGED;
  static inline bool NewState_IsValid(int value) {
    return BulkUpdateWorkRequest_NewState_IsValid(value);
  }
  static constexpr NewState NewState_MIN = BulkUpdateWorkRequest_NewState_NewState_MIN;
  static constexpr NewState NewState_MAX = BulkUpdateWorkRequest_NewState_NewState_MAX;
  static constexpr int NewState_ARRAYSIZE = BulkUpdateWorkRequest_NewState_NewState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* NewState_descriptor() {
    return BulkUpdateWorkRequest_NewState_descriptor();
  }
  template <typename T>
  static inline const std::string& NewState_Name(T value) {
    return BulkUpdateWorkRequest_NewState_Name(value);
  }
  static inline bool NewState_Parse(absl::string_view name, NewState* value) {
    return BulkUpdateWorkRequest_NewState_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kNewStateFieldNumber = 1,
  };
  // .flex.BulkUpdateWorkRequest.NewState new_state = 1;
  void clear_new_state() ;
  ::flex::BulkUpdateWorkRequest_NewState new_state() const;
  void set_new_state(::flex::BulkUpdateWorkRequest_NewState value);

  private:
  ::flex::BulkUpdateWorkRequest_NewState _internal_new_state() const;
  void _internal_set_new_state(::flex::BulkUpdateWorkRequest_NewState value);

  public:
  // @@protoc_insertion_point(class_scope:flex.BulkUpdateWorkRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BulkUpdateWorkRequest& from_msg);
    int new_state_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class BeeRemoteNode final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.BeeRemoteNode) */ {
 public:
  inline BeeRemoteNode() : BeeRemoteNode(nullptr) {}
  ~BeeRemoteNode() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BeeRemoteNode* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BeeRemoteNode));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BeeRemoteNode(
      ::google::protobuf::internal::ConstantInitialized);

  inline BeeRemoteNode(const BeeRemoteNode& from) : BeeRemoteNode(nullptr, from) {}
  inline BeeRemoteNode(BeeRemoteNode&& from) noexcept
      : BeeRemoteNode(nullptr, std::move(from)) {}
  inline BeeRemoteNode& operator=(const BeeRemoteNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeeRemoteNode& operator=(BeeRemoteNode&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeeRemoteNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeeRemoteNode* internal_default_instance() {
    return reinterpret_cast<const BeeRemoteNode*>(
        &_BeeRemoteNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(BeeRemoteNode& a, BeeRemoteNode& b) { a.Swap(&b); }
  inline void Swap(BeeRemoteNode* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeeRemoteNode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeeRemoteNode* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BeeRemoteNode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BeeRemoteNode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BeeRemoteNode& from) { BeeRemoteNode::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BeeRemoteNode* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.BeeRemoteNode"; }

 protected:
  explicit BeeRemoteNode(::google::protobuf::Arena* arena);
  BeeRemoteNode(::google::protobuf::Arena* arena, const BeeRemoteNode& from);
  BeeRemoteNode(::google::protobuf::Arena* arena, BeeRemoteNode&& from) noexcept
      : BeeRemoteNode(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kAddressFieldNumber = 2,
  };
  // string id = 1;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string address = 2;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // @@protoc_insertion_point(class_scope:flex.BeeRemoteNode)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      36, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BeeRemoteNode& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class WorkRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.WorkRequest) */ {
 public:
  inline WorkRequest() : WorkRequest(nullptr) {}
  ~WorkRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(WorkRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(WorkRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WorkRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline WorkRequest(const WorkRequest& from) : WorkRequest(nullptr, from) {}
  inline WorkRequest(WorkRequest&& from) noexcept
      : WorkRequest(nullptr, std::move(from)) {}
  inline WorkRequest& operator=(const WorkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkRequest& operator=(WorkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkRequest& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kMock = 10,
    kSync = 11,
    TYPE_NOT_SET = 0,
  };
  static inline const WorkRequest* internal_default_instance() {
    return reinterpret_cast<const WorkRequest*>(
        &_WorkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(WorkRequest& a, WorkRequest& b) { a.Swap(&b); }
  inline void Swap(WorkRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<WorkRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorkRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WorkRequest& from) { WorkRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(WorkRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.WorkRequest"; }

 protected:
  explicit WorkRequest(::google::protobuf::Arena* arena);
  WorkRequest(::google::protobuf::Arena* arena, const WorkRequest& from);
  WorkRequest(::google::protobuf::Arena* arena, WorkRequest&& from) noexcept
      : WorkRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Segment = WorkRequest_Segment;

  // accessors -------------------------------------------------------
  enum : int {
    kJobIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
    kExternalIdFieldNumber = 3,
    kPathFieldNumber = 4,
    kSegmentFieldNumber = 5,
    kRemoteStorageTargetFieldNumber = 6,
    kJobBuilderFieldNumber = 7,
    kStubLocalFieldNumber = 8,
    kMockFieldNumber = 10,
    kSyncFieldNumber = 11,
  };
  // string job_id = 1;
  void clear_job_id() ;
  const std::string& job_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_job_id(Arg_&& arg, Args_... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* value);

  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(
      const std::string& value);
  std::string* _internal_mutable_job_id();

  public:
  // string request_id = 2;
  void clear_request_id() ;
  const std::string& request_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_request_id(Arg_&& arg, Args_... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* value);

  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(
      const std::string& value);
  std::string* _internal_mutable_request_id();

  public:
  // string external_id = 3;
  void clear_external_id() ;
  const std::string& external_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_external_id(Arg_&& arg, Args_... args);
  std::string* mutable_external_id();
  PROTOBUF_NODISCARD std::string* release_external_id();
  void set_allocated_external_id(std::string* value);

  private:
  const std::string& _internal_external_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_external_id(
      const std::string& value);
  std::string* _internal_mutable_external_id();

  public:
  // string path = 4;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // .flex.WorkRequest.Segment segment = 5;
  bool has_segment() const;
  void clear_segment() ;
  const ::flex::WorkRequest_Segment& segment() const;
  PROTOBUF_NODISCARD ::flex::WorkRequest_Segment* release_segment();
  ::flex::WorkRequest_Segment* mutable_segment();
  void set_allocated_segment(::flex::WorkRequest_Segment* value);
  void unsafe_arena_set_allocated_segment(::flex::WorkRequest_Segment* value);
  ::flex::WorkRequest_Segment* unsafe_arena_release_segment();

  private:
  const ::flex::WorkRequest_Segment& _internal_segment() const;
  ::flex::WorkRequest_Segment* _internal_mutable_segment();

  public:
  // uint32 remote_storage_target = 6;
  void clear_remote_storage_target() ;
  ::uint32_t remote_storage_target() const;
  void set_remote_storage_target(::uint32_t value);

  private:
  ::uint32_t _internal_remote_storage_target() const;
  void _internal_set_remote_storage_target(::uint32_t value);

  public:
  // bool job_builder = 7;
  void clear_job_builder() ;
  bool job_builder() const;
  void set_job_builder(bool value);

  private:
  bool _internal_job_builder() const;
  void _internal_set_job_builder(bool value);

  public:
  // bool stub_local = 8;
  void clear_stub_local() ;
  bool stub_local() const;
  void set_stub_local(bool value);

  private:
  bool _internal_stub_local() const;
  void _internal_set_stub_local(bool value);

  public:
  // .flex.MockJob mock = 10;
  bool has_mock() const;
  private:
  bool _internal_has_mock() const;

  public:
  void clear_mock() ;
  const ::flex::MockJob& mock() const;
  PROTOBUF_NODISCARD ::flex::MockJob* release_mock();
  ::flex::MockJob* mutable_mock();
  void set_allocated_mock(::flex::MockJob* value);
  void unsafe_arena_set_allocated_mock(::flex::MockJob* value);
  ::flex::MockJob* unsafe_arena_release_mock();

  private:
  const ::flex::MockJob& _internal_mock() const;
  ::flex::MockJob* _internal_mutable_mock();

  public:
  // .flex.SyncJob sync = 11;
  bool has_sync() const;
  private:
  bool _internal_has_sync() const;

  public:
  void clear_sync() ;
  const ::flex::SyncJob& sync() const;
  PROTOBUF_NODISCARD ::flex::SyncJob* release_sync();
  ::flex::SyncJob* mutable_sync();
  void set_allocated_sync(::flex::SyncJob* value);
  void unsafe_arena_set_allocated_sync(::flex::SyncJob* value);
  ::flex::SyncJob* unsafe_arena_release_sync();

  private:
  const ::flex::SyncJob& _internal_sync() const;
  ::flex::SyncJob* _internal_mutable_sync();

  public:
  void clear_Type();
  TypeCase Type_case() const;
  // @@protoc_insertion_point(class_scope:flex.WorkRequest)
 private:
  class _Internal;
  void set_has_mock();
  void set_has_sync();
  inline bool has_Type() const;
  inline void clear_has_Type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 10, 3,
      64, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const WorkRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr job_id_;
    ::google::protobuf::internal::ArenaStringPtr request_id_;
    ::google::protobuf::internal::ArenaStringPtr external_id_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::flex::WorkRequest_Segment* segment_;
    ::uint32_t remote_storage_target_;
    bool job_builder_;
    bool stub_local_;
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::flex::MockJob* mock_;
      ::flex::SyncJob* sync_;
    } Type_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class Work final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.Work) */ {
 public:
  inline Work() : Work(nullptr) {}
  ~Work() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Work* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Work));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Work(
      ::google::protobuf::internal::ConstantInitialized);

  inline Work(const Work& from) : Work(nullptr, from) {}
  inline Work(Work&& from) noexcept
      : Work(nullptr, std::move(from)) {}
  inline Work& operator=(const Work& from) {
    CopyFrom(from);
    return *this;
  }
  inline Work& operator=(Work&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Work& default_instance() {
    return *internal_default_instance();
  }
  static inline const Work* internal_default_instance() {
    return reinterpret_cast<const Work*>(
        &_Work_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(Work& a, Work& b) { a.Swap(&b); }
  inline void Swap(Work* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Work* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Work* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Work>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Work& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Work& from) { Work::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Work* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.Work"; }

 protected:
  explicit Work(::google::protobuf::Arena* arena);
  Work(::google::protobuf::Arena* arena, const Work& from);
  Work(::google::protobuf::Arena* arena, Work&& from) noexcept
      : Work(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Status = Work_Status;
  using Part = Work_Part;
  using State = Work_State;
  static constexpr State UNSPECIFIED = Work_State_UNSPECIFIED;
  static constexpr State UNKNOWN = Work_State_UNKNOWN;
  static constexpr State CREATED = Work_State_CREATED;
  static constexpr State SCHEDULED = Work_State_SCHEDULED;
  static constexpr State RUNNING = Work_State_RUNNING;
  static constexpr State ERROR = Work_State_ERROR;
  static constexpr State FAILED = Work_State_FAILED;
  static constexpr State CANCELLED = Work_State_CANCELLED;
  static constexpr State COMPLETED = Work_State_COMPLETED;
  static inline bool State_IsValid(int value) {
    return Work_State_IsValid(value);
  }
  static constexpr State State_MIN = Work_State_State_MIN;
  static constexpr State State_MAX = Work_State_State_MAX;
  static constexpr int State_ARRAYSIZE = Work_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* State_descriptor() {
    return Work_State_descriptor();
  }
  template <typename T>
  static inline const std::string& State_Name(T value) {
    return Work_State_Name(value);
  }
  static inline bool State_Parse(absl::string_view name, State* value) {
    return Work_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kPartsFieldNumber = 5,
    kPathFieldNumber = 1,
    kJobIdFieldNumber = 2,
    kRequestIdFieldNumber = 3,
    kStatusFieldNumber = 4,
    kJobBuilderFieldNumber = 6,
  };
  // repeated .flex.Work.Part parts = 5;
  int parts_size() const;
  private:
  int _internal_parts_size() const;

  public:
  void clear_parts() ;
  ::flex::Work_Part* mutable_parts(int index);
  ::google::protobuf::RepeatedPtrField<::flex::Work_Part>* mutable_parts();

  private:
  const ::google::protobuf::RepeatedPtrField<::flex::Work_Part>& _internal_parts() const;
  ::google::protobuf::RepeatedPtrField<::flex::Work_Part>* _internal_mutable_parts();
  public:
  const ::flex::Work_Part& parts(int index) const;
  ::flex::Work_Part* add_parts();
  const ::google::protobuf::RepeatedPtrField<::flex::Work_Part>& parts() const;
  // string path = 1;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // string job_id = 2;
  void clear_job_id() ;
  const std::string& job_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_job_id(Arg_&& arg, Args_... args);
  std::string* mutable_job_id();
  PROTOBUF_NODISCARD std::string* release_job_id();
  void set_allocated_job_id(std::string* value);

  private:
  const std::string& _internal_job_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_id(
      const std::string& value);
  std::string* _internal_mutable_job_id();

  public:
  // string request_id = 3;
  void clear_request_id() ;
  const std::string& request_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_request_id(Arg_&& arg, Args_... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* value);

  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(
      const std::string& value);
  std::string* _internal_mutable_request_id();

  public:
  // .flex.Work.Status status = 4;
  bool has_status() const;
  void clear_status() ;
  const ::flex::Work_Status& status() const;
  PROTOBUF_NODISCARD ::flex::Work_Status* release_status();
  ::flex::Work_Status* mutable_status();
  void set_allocated_status(::flex::Work_Status* value);
  void unsafe_arena_set_allocated_status(::flex::Work_Status* value);
  ::flex::Work_Status* unsafe_arena_release_status();

  private:
  const ::flex::Work_Status& _internal_status() const;
  ::flex::Work_Status* _internal_mutable_status();

  public:
  // bool job_builder = 6;
  void clear_job_builder() ;
  bool job_builder() const;
  void set_job_builder(bool value);

  private:
  bool _internal_job_builder() const;
  void _internal_set_job_builder(bool value);

  public:
  // @@protoc_insertion_point(class_scope:flex.Work)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      38, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Work& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::flex::Work_Part > parts_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::google::protobuf::internal::ArenaStringPtr job_id_;
    ::google::protobuf::internal::ArenaStringPtr request_id_;
    ::flex::Work_Status* status_;
    bool job_builder_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class RemoteStorageTarget_Azure final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.RemoteStorageTarget.Azure) */ {
 public:
  inline RemoteStorageTarget_Azure() : RemoteStorageTarget_Azure(nullptr) {}
  ~RemoteStorageTarget_Azure() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RemoteStorageTarget_Azure* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RemoteStorageTarget_Azure));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RemoteStorageTarget_Azure(
      ::google::protobuf::internal::ConstantInitialized);

  inline RemoteStorageTarget_Azure(const RemoteStorageTarget_Azure& from) : RemoteStorageTarget_Azure(nullptr, from) {}
  inline RemoteStorageTarget_Azure(RemoteStorageTarget_Azure&& from) noexcept
      : RemoteStorageTarget_Azure(nullptr, std::move(from)) {}
  inline RemoteStorageTarget_Azure& operator=(const RemoteStorageTarget_Azure& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteStorageTarget_Azure& operator=(RemoteStorageTarget_Azure&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteStorageTarget_Azure& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteStorageTarget_Azure* internal_default_instance() {
    return reinterpret_cast<const RemoteStorageTarget_Azure*>(
        &_RemoteStorageTarget_Azure_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(RemoteStorageTarget_Azure& a, RemoteStorageTarget_Azure& b) { a.Swap(&b); }
  inline void Swap(RemoteStorageTarget_Azure* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteStorageTarget_Azure* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteStorageTarget_Azure* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RemoteStorageTarget_Azure>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RemoteStorageTarget_Azure& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RemoteStorageTarget_Azure& from) { RemoteStorageTarget_Azure::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RemoteStorageTarget_Azure* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.RemoteStorageTarget.Azure"; }

 protected:
  explicit RemoteStorageTarget_Azure(::google::protobuf::Arena* arena);
  RemoteStorageTarget_Azure(::google::protobuf::Arena* arena, const RemoteStorageTarget_Azure& from);
  RemoteStorageTarget_Azure(::google::protobuf::Arena* arena, RemoteStorageTarget_Azure&& from) noexcept
      : RemoteStorageTarget_Azure(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAccountFieldNumber = 2,
    kS3FieldNumber = 1,
  };
  // string account = 2;
  void clear_account() ;
  const std::string& account() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account(Arg_&& arg, Args_... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* value);

  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(
      const std::string& value);
  std::string* _internal_mutable_account();

  public:
  // .flex.RemoteStorageTarget.S3 s3 = 1;
  bool has_s3() const;
  void clear_s3() ;
  const ::flex::RemoteStorageTarget_S3& s3() const;
  PROTOBUF_NODISCARD ::flex::RemoteStorageTarget_S3* release_s3();
  ::flex::RemoteStorageTarget_S3* mutable_s3();
  void set_allocated_s3(::flex::RemoteStorageTarget_S3* value);
  void unsafe_arena_set_allocated_s3(::flex::RemoteStorageTarget_S3* value);
  ::flex::RemoteStorageTarget_S3* unsafe_arena_release_s3();

  private:
  const ::flex::RemoteStorageTarget_S3& _internal_s3() const;
  ::flex::RemoteStorageTarget_S3* _internal_mutable_s3();

  public:
  // @@protoc_insertion_point(class_scope:flex.RemoteStorageTarget.Azure)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      46, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RemoteStorageTarget_Azure& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr account_;
    ::flex::RemoteStorageTarget_S3* s3_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class NodeStats final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.NodeStats) */ {
 public:
  inline NodeStats() : NodeStats(nullptr) {}
  ~NodeStats() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NodeStats* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NodeStats));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeStats(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeStats(const NodeStats& from) : NodeStats(nullptr, from) {}
  inline NodeStats(NodeStats&& from) noexcept
      : NodeStats(nullptr, std::move(from)) {}
  inline NodeStats& operator=(const NodeStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeStats& operator=(NodeStats&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeStats* internal_default_instance() {
    return reinterpret_cast<const NodeStats*>(
        &_NodeStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(NodeStats& a, NodeStats& b) { a.Swap(&b); }
  inline void Swap(NodeStats* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeStats* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeStats* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NodeStats>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeStats& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeStats& from) { NodeStats::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NodeStats* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.NodeStats"; }

 protected:
  explicit NodeStats(::google::protobuf::Arena* arena);
  NodeStats(::google::protobuf::Arena* arena, const NodeStats& from);
  NodeStats(::google::protobuf::Arena* arena, NodeStats&& from) noexcept
      : NodeStats(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimestampFieldNumber = 1,
    kActiveRequestsFieldNumber = 2,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // int64 active_requests = 2;
  void clear_active_requests() ;
  ::int64_t active_requests() const;
  void set_active_requests(::int64_t value);

  private:
  ::int64_t _internal_active_requests() const;
  void _internal_set_active_requests(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:flex.NodeStats)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NodeStats& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* timestamp_;
    ::int64_t active_requests_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class UpdateWorkResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.UpdateWorkResponse) */ {
 public:
  inline UpdateWorkResponse() : UpdateWorkResponse(nullptr) {}
  ~UpdateWorkResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateWorkResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateWorkResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateWorkResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateWorkResponse(const UpdateWorkResponse& from) : UpdateWorkResponse(nullptr, from) {}
  inline UpdateWorkResponse(UpdateWorkResponse&& from) noexcept
      : UpdateWorkResponse(nullptr, std::move(from)) {}
  inline UpdateWorkResponse& operator=(const UpdateWorkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateWorkResponse& operator=(UpdateWorkResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateWorkResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateWorkResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateWorkResponse*>(
        &_UpdateWorkResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(UpdateWorkResponse& a, UpdateWorkResponse& b) { a.Swap(&b); }
  inline void Swap(UpdateWorkResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateWorkResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateWorkResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateWorkResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateWorkResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateWorkResponse& from) { UpdateWorkResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateWorkResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.UpdateWorkResponse"; }

 protected:
  explicit UpdateWorkResponse(::google::protobuf::Arena* arena);
  UpdateWorkResponse(::google::protobuf::Arena* arena, const UpdateWorkResponse& from);
  UpdateWorkResponse(::google::protobuf::Arena* arena, UpdateWorkResponse&& from) noexcept
      : UpdateWorkResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWorkFieldNumber = 1,
  };
  // .flex.Work work = 1;
  bool has_work() const;
  void clear_work() ;
  const ::flex::Work& work() const;
  PROTOBUF_NODISCARD ::flex::Work* release_work();
  ::flex::Work* mutable_work();
  void set_allocated_work(::flex::Work* value);
  void unsafe_arena_set_allocated_work(::flex::Work* value);
  ::flex::Work* unsafe_arena_release_work();

  private:
  const ::flex::Work& _internal_work() const;
  ::flex::Work* _internal_mutable_work();

  public:
  // @@protoc_insertion_point(class_scope:flex.UpdateWorkResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateWorkResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::flex::Work* work_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class SubmitWorkResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.SubmitWorkResponse) */ {
 public:
  inline SubmitWorkResponse() : SubmitWorkResponse(nullptr) {}
  ~SubmitWorkResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubmitWorkResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubmitWorkResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubmitWorkResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline SubmitWorkResponse(const SubmitWorkResponse& from) : SubmitWorkResponse(nullptr, from) {}
  inline SubmitWorkResponse(SubmitWorkResponse&& from) noexcept
      : SubmitWorkResponse(nullptr, std::move(from)) {}
  inline SubmitWorkResponse& operator=(const SubmitWorkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitWorkResponse& operator=(SubmitWorkResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitWorkResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitWorkResponse* internal_default_instance() {
    return reinterpret_cast<const SubmitWorkResponse*>(
        &_SubmitWorkResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(SubmitWorkResponse& a, SubmitWorkResponse& b) { a.Swap(&b); }
  inline void Swap(SubmitWorkResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitWorkResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitWorkResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubmitWorkResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubmitWorkResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubmitWorkResponse& from) { SubmitWorkResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubmitWorkResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.SubmitWorkResponse"; }

 protected:
  explicit SubmitWorkResponse(::google::protobuf::Arena* arena);
  SubmitWorkResponse(::google::protobuf::Arena* arena, const SubmitWorkResponse& from);
  SubmitWorkResponse(::google::protobuf::Arena* arena, SubmitWorkResponse&& from) noexcept
      : SubmitWorkResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWorkFieldNumber = 1,
  };
  // .flex.Work work = 1;
  bool has_work() const;
  void clear_work() ;
  const ::flex::Work& work() const;
  PROTOBUF_NODISCARD ::flex::Work* release_work();
  ::flex::Work* mutable_work();
  void set_allocated_work(::flex::Work* value);
  void unsafe_arena_set_allocated_work(::flex::Work* value);
  ::flex::Work* unsafe_arena_release_work();

  private:
  const ::flex::Work& _internal_work() const;
  ::flex::Work* _internal_mutable_work();

  public:
  // @@protoc_insertion_point(class_scope:flex.SubmitWorkResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SubmitWorkResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::flex::Work* work_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class SubmitWorkRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.SubmitWorkRequest) */ {
 public:
  inline SubmitWorkRequest() : SubmitWorkRequest(nullptr) {}
  ~SubmitWorkRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubmitWorkRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubmitWorkRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubmitWorkRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SubmitWorkRequest(const SubmitWorkRequest& from) : SubmitWorkRequest(nullptr, from) {}
  inline SubmitWorkRequest(SubmitWorkRequest&& from) noexcept
      : SubmitWorkRequest(nullptr, std::move(from)) {}
  inline SubmitWorkRequest& operator=(const SubmitWorkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitWorkRequest& operator=(SubmitWorkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitWorkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitWorkRequest* internal_default_instance() {
    return reinterpret_cast<const SubmitWorkRequest*>(
        &_SubmitWorkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(SubmitWorkRequest& a, SubmitWorkRequest& b) { a.Swap(&b); }
  inline void Swap(SubmitWorkRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitWorkRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitWorkRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubmitWorkRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubmitWorkRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubmitWorkRequest& from) { SubmitWorkRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubmitWorkRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.SubmitWorkRequest"; }

 protected:
  explicit SubmitWorkRequest(::google::protobuf::Arena* arena);
  SubmitWorkRequest(::google::protobuf::Arena* arena, const SubmitWorkRequest& from);
  SubmitWorkRequest(::google::protobuf::Arena* arena, SubmitWorkRequest&& from) noexcept
      : SubmitWorkRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRequestFieldNumber = 1,
  };
  // .flex.WorkRequest request = 1;
  bool has_request() const;
  void clear_request() ;
  const ::flex::WorkRequest& request() const;
  PROTOBUF_NODISCARD ::flex::WorkRequest* release_request();
  ::flex::WorkRequest* mutable_request();
  void set_allocated_request(::flex::WorkRequest* value);
  void unsafe_arena_set_allocated_request(::flex::WorkRequest* value);
  ::flex::WorkRequest* unsafe_arena_release_request();

  private:
  const ::flex::WorkRequest& _internal_request() const;
  ::flex::WorkRequest* _internal_mutable_request();

  public:
  // @@protoc_insertion_point(class_scope:flex.SubmitWorkRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SubmitWorkRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::flex::WorkRequest* request_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class RemoteStorageTarget final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.RemoteStorageTarget) */ {
 public:
  inline RemoteStorageTarget() : RemoteStorageTarget(nullptr) {}
  ~RemoteStorageTarget() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RemoteStorageTarget* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RemoteStorageTarget));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RemoteStorageTarget(
      ::google::protobuf::internal::ConstantInitialized);

  inline RemoteStorageTarget(const RemoteStorageTarget& from) : RemoteStorageTarget(nullptr, from) {}
  inline RemoteStorageTarget(RemoteStorageTarget&& from) noexcept
      : RemoteStorageTarget(nullptr, std::move(from)) {}
  inline RemoteStorageTarget& operator=(const RemoteStorageTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteStorageTarget& operator=(RemoteStorageTarget&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteStorageTarget& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kS3 = 4,
    kPosix = 5,
    kAzure = 6,
    kMock = 7,
    TYPE_NOT_SET = 0,
  };
  static inline const RemoteStorageTarget* internal_default_instance() {
    return reinterpret_cast<const RemoteStorageTarget*>(
        &_RemoteStorageTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(RemoteStorageTarget& a, RemoteStorageTarget& b) { a.Swap(&b); }
  inline void Swap(RemoteStorageTarget* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteStorageTarget* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteStorageTarget* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RemoteStorageTarget>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RemoteStorageTarget& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RemoteStorageTarget& from) { RemoteStorageTarget::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RemoteStorageTarget* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.RemoteStorageTarget"; }

 protected:
  explicit RemoteStorageTarget(::google::protobuf::Arena* arena);
  RemoteStorageTarget(::google::protobuf::Arena* arena, const RemoteStorageTarget& from);
  RemoteStorageTarget(::google::protobuf::Arena* arena, RemoteStorageTarget&& from) noexcept
      : RemoteStorageTarget(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Policies = RemoteStorageTarget_Policies;
  using S3 = RemoteStorageTarget_S3;
  using Azure = RemoteStorageTarget_Azure;
  using POSIX = RemoteStorageTarget_POSIX;

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 2,
    kPoliciesFieldNumber = 3,
    kIdFieldNumber = 1,
    kS3FieldNumber = 4,
    kPosixFieldNumber = 5,
    kAzureFieldNumber = 6,
    kMockFieldNumber = 7,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .flex.RemoteStorageTarget.Policies policies = 3;
  bool has_policies() const;
  void clear_policies() ;
  const ::flex::RemoteStorageTarget_Policies& policies() const;
  PROTOBUF_NODISCARD ::flex::RemoteStorageTarget_Policies* release_policies();
  ::flex::RemoteStorageTarget_Policies* mutable_policies();
  void set_allocated_policies(::flex::RemoteStorageTarget_Policies* value);
  void unsafe_arena_set_allocated_policies(::flex::RemoteStorageTarget_Policies* value);
  ::flex::RemoteStorageTarget_Policies* unsafe_arena_release_policies();

  private:
  const ::flex::RemoteStorageTarget_Policies& _internal_policies() const;
  ::flex::RemoteStorageTarget_Policies* _internal_mutable_policies();

  public:
  // uint32 id = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // .flex.RemoteStorageTarget.S3 s3 = 4;
  bool has_s3() const;
  private:
  bool _internal_has_s3() const;

  public:
  void clear_s3() ;
  const ::flex::RemoteStorageTarget_S3& s3() const;
  PROTOBUF_NODISCARD ::flex::RemoteStorageTarget_S3* release_s3();
  ::flex::RemoteStorageTarget_S3* mutable_s3();
  void set_allocated_s3(::flex::RemoteStorageTarget_S3* value);
  void unsafe_arena_set_allocated_s3(::flex::RemoteStorageTarget_S3* value);
  ::flex::RemoteStorageTarget_S3* unsafe_arena_release_s3();

  private:
  const ::flex::RemoteStorageTarget_S3& _internal_s3() const;
  ::flex::RemoteStorageTarget_S3* _internal_mutable_s3();

  public:
  // .flex.RemoteStorageTarget.POSIX posix = 5;
  bool has_posix() const;
  private:
  bool _internal_has_posix() const;

  public:
  void clear_posix() ;
  const ::flex::RemoteStorageTarget_POSIX& posix() const;
  PROTOBUF_NODISCARD ::flex::RemoteStorageTarget_POSIX* release_posix();
  ::flex::RemoteStorageTarget_POSIX* mutable_posix();
  void set_allocated_posix(::flex::RemoteStorageTarget_POSIX* value);
  void unsafe_arena_set_allocated_posix(::flex::RemoteStorageTarget_POSIX* value);
  ::flex::RemoteStorageTarget_POSIX* unsafe_arena_release_posix();

  private:
  const ::flex::RemoteStorageTarget_POSIX& _internal_posix() const;
  ::flex::RemoteStorageTarget_POSIX* _internal_mutable_posix();

  public:
  // .flex.RemoteStorageTarget.Azure azure = 6;
  bool has_azure() const;
  private:
  bool _internal_has_azure() const;

  public:
  void clear_azure() ;
  const ::flex::RemoteStorageTarget_Azure& azure() const;
  PROTOBUF_NODISCARD ::flex::RemoteStorageTarget_Azure* release_azure();
  ::flex::RemoteStorageTarget_Azure* mutable_azure();
  void set_allocated_azure(::flex::RemoteStorageTarget_Azure* value);
  void unsafe_arena_set_allocated_azure(::flex::RemoteStorageTarget_Azure* value);
  ::flex::RemoteStorageTarget_Azure* unsafe_arena_release_azure();

  private:
  const ::flex::RemoteStorageTarget_Azure& _internal_azure() const;
  ::flex::RemoteStorageTarget_Azure* _internal_mutable_azure();

  public:
  // string mock = 7;
  bool has_mock() const;
  void clear_mock() ;
  const std::string& mock() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mock(Arg_&& arg, Args_... args);
  std::string* mutable_mock();
  PROTOBUF_NODISCARD std::string* release_mock();
  void set_allocated_mock(std::string* value);

  private:
  const std::string& _internal_mock() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mock(
      const std::string& value);
  std::string* _internal_mutable_mock();

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:flex.RemoteStorageTarget)
 private:
  class _Internal;
  void set_has_s3();
  void set_has_posix();
  void set_has_azure();
  void set_has_mock();
  inline bool has_type() const;
  inline void clear_has_type();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 7, 4,
      41, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RemoteStorageTarget& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::flex::RemoteStorageTarget_Policies* policies_;
    ::uint32_t id_;
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::flex::RemoteStorageTarget_S3* s3_;
      ::flex::RemoteStorageTarget_POSIX* posix_;
      ::flex::RemoteStorageTarget_Azure* azure_;
      ::google::protobuf::internal::ArenaStringPtr mock_;
    } type_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.HeartbeatResponse) */ {
 public:
  inline HeartbeatResponse() : HeartbeatResponse(nullptr) {}
  ~HeartbeatResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HeartbeatResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HeartbeatResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HeartbeatResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline HeartbeatResponse(const HeartbeatResponse& from) : HeartbeatResponse(nullptr, from) {}
  inline HeartbeatResponse(HeartbeatResponse&& from) noexcept
      : HeartbeatResponse(nullptr, std::move(from)) {}
  inline HeartbeatResponse& operator=(const HeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatResponse& operator=(HeartbeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const HeartbeatResponse*>(
        &_HeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(HeartbeatResponse& a, HeartbeatResponse& b) { a.Swap(&b); }
  inline void Swap(HeartbeatResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HeartbeatResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeartbeatResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HeartbeatResponse& from) { HeartbeatResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HeartbeatResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.HeartbeatResponse"; }

 protected:
  explicit HeartbeatResponse(::google::protobuf::Arena* arena);
  HeartbeatResponse(::google::protobuf::Arena* arena, const HeartbeatResponse& from);
  HeartbeatResponse(::google::protobuf::Arena* arena, HeartbeatResponse&& from) noexcept
      : HeartbeatResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeStatsFieldNumber = 2,
    kIsReadyFieldNumber = 1,
  };
  // .flex.NodeStats node_stats = 2;
  bool has_node_stats() const;
  void clear_node_stats() ;
  const ::flex::NodeStats& node_stats() const;
  PROTOBUF_NODISCARD ::flex::NodeStats* release_node_stats();
  ::flex::NodeStats* mutable_node_stats();
  void set_allocated_node_stats(::flex::NodeStats* value);
  void unsafe_arena_set_allocated_node_stats(::flex::NodeStats* value);
  ::flex::NodeStats* unsafe_arena_release_node_stats();

  private:
  const ::flex::NodeStats& _internal_node_stats() const;
  ::flex::NodeStats* _internal_mutable_node_stats();

  public:
  // bool is_ready = 1;
  void clear_is_ready() ;
  bool is_ready() const;
  void set_is_ready(bool value);

  private:
  bool _internal_is_ready() const;
  void _internal_set_is_ready(bool value);

  public:
  // @@protoc_insertion_point(class_scope:flex.HeartbeatResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HeartbeatResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::flex::NodeStats* node_stats_;
    bool is_ready_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};
// -------------------------------------------------------------------

class UpdateConfigRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:flex.UpdateConfigRequest) */ {
 public:
  inline UpdateConfigRequest() : UpdateConfigRequest(nullptr) {}
  ~UpdateConfigRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateConfigRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateConfigRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateConfigRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateConfigRequest(const UpdateConfigRequest& from) : UpdateConfigRequest(nullptr, from) {}
  inline UpdateConfigRequest(UpdateConfigRequest&& from) noexcept
      : UpdateConfigRequest(nullptr, std::move(from)) {}
  inline UpdateConfigRequest& operator=(const UpdateConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateConfigRequest& operator=(UpdateConfigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateConfigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateConfigRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateConfigRequest*>(
        &_UpdateConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(UpdateConfigRequest& a, UpdateConfigRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateConfigRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateConfigRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateConfigRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateConfigRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateConfigRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateConfigRequest& from) { UpdateConfigRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateConfigRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "flex.UpdateConfigRequest"; }

 protected:
  explicit UpdateConfigRequest(::google::protobuf::Arena* arena);
  UpdateConfigRequest(::google::protobuf::Arena* arena, const UpdateConfigRequest& from);
  UpdateConfigRequest(::google::protobuf::Arena* arena, UpdateConfigRequest&& from) noexcept
      : UpdateConfigRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRstsFieldNumber = 2,
    kBeeRemoteFieldNumber = 1,
  };
  // repeated .flex.RemoteStorageTarget rsts = 2;
  int rsts_size() const;
  private:
  int _internal_rsts_size() const;

  public:
  void clear_rsts() ;
  ::flex::RemoteStorageTarget* mutable_rsts(int index);
  ::google::protobuf::RepeatedPtrField<::flex::RemoteStorageTarget>* mutable_rsts();

  private:
  const ::google::protobuf::RepeatedPtrField<::flex::RemoteStorageTarget>& _internal_rsts() const;
  ::google::protobuf::RepeatedPtrField<::flex::RemoteStorageTarget>* _internal_mutable_rsts();
  public:
  const ::flex::RemoteStorageTarget& rsts(int index) const;
  ::flex::RemoteStorageTarget* add_rsts();
  const ::google::protobuf::RepeatedPtrField<::flex::RemoteStorageTarget>& rsts() const;
  // .flex.BeeRemoteNode bee_remote = 1;
  bool has_bee_remote() const;
  void clear_bee_remote() ;
  const ::flex::BeeRemoteNode& bee_remote() const;
  PROTOBUF_NODISCARD ::flex::BeeRemoteNode* release_bee_remote();
  ::flex::BeeRemoteNode* mutable_bee_remote();
  void set_allocated_bee_remote(::flex::BeeRemoteNode* value);
  void unsafe_arena_set_allocated_bee_remote(::flex::BeeRemoteNode* value);
  ::flex::BeeRemoteNode* unsafe_arena_release_bee_remote();

  private:
  const ::flex::BeeRemoteNode& _internal_bee_remote() const;
  ::flex::BeeRemoteNode* _internal_mutable_bee_remote();

  public:
  // @@protoc_insertion_point(class_scope:flex.UpdateConfigRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateConfigRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::flex::RemoteStorageTarget > rsts_;
    ::flex::BeeRemoteNode* bee_remote_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_flex_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// HeartbeatRequest

// bool include_stats = 1;
inline void HeartbeatRequest::clear_include_stats() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.include_stats_ = false;
}
inline bool HeartbeatRequest::include_stats() const {
  // @@protoc_insertion_point(field_get:flex.HeartbeatRequest.include_stats)
  return _internal_include_stats();
}
inline void HeartbeatRequest::set_include_stats(bool value) {
  _internal_set_include_stats(value);
  // @@protoc_insertion_point(field_set:flex.HeartbeatRequest.include_stats)
}
inline bool HeartbeatRequest::_internal_include_stats() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.include_stats_;
}
inline void HeartbeatRequest::_internal_set_include_stats(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.include_stats_ = value;
}

// -------------------------------------------------------------------

// HeartbeatResponse

// bool is_ready = 1;
inline void HeartbeatResponse::clear_is_ready() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_ready_ = false;
}
inline bool HeartbeatResponse::is_ready() const {
  // @@protoc_insertion_point(field_get:flex.HeartbeatResponse.is_ready)
  return _internal_is_ready();
}
inline void HeartbeatResponse::set_is_ready(bool value) {
  _internal_set_is_ready(value);
  // @@protoc_insertion_point(field_set:flex.HeartbeatResponse.is_ready)
}
inline bool HeartbeatResponse::_internal_is_ready() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_ready_;
}
inline void HeartbeatResponse::_internal_set_is_ready(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_ready_ = value;
}

// .flex.NodeStats node_stats = 2;
inline bool HeartbeatResponse::has_node_stats() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.node_stats_ != nullptr);
  return value;
}
inline void HeartbeatResponse::clear_node_stats() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.node_stats_ != nullptr) _impl_.node_stats_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::flex::NodeStats& HeartbeatResponse::_internal_node_stats() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::flex::NodeStats* p = _impl_.node_stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::flex::NodeStats&>(::flex::_NodeStats_default_instance_);
}
inline const ::flex::NodeStats& HeartbeatResponse::node_stats() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.HeartbeatResponse.node_stats)
  return _internal_node_stats();
}
inline void HeartbeatResponse::unsafe_arena_set_allocated_node_stats(::flex::NodeStats* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.node_stats_);
  }
  _impl_.node_stats_ = reinterpret_cast<::flex::NodeStats*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.HeartbeatResponse.node_stats)
}
inline ::flex::NodeStats* HeartbeatResponse::release_node_stats() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::flex::NodeStats* released = _impl_.node_stats_;
  _impl_.node_stats_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::flex::NodeStats* HeartbeatResponse::unsafe_arena_release_node_stats() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.HeartbeatResponse.node_stats)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::flex::NodeStats* temp = _impl_.node_stats_;
  _impl_.node_stats_ = nullptr;
  return temp;
}
inline ::flex::NodeStats* HeartbeatResponse::_internal_mutable_node_stats() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.node_stats_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::flex::NodeStats>(GetArena());
    _impl_.node_stats_ = reinterpret_cast<::flex::NodeStats*>(p);
  }
  return _impl_.node_stats_;
}
inline ::flex::NodeStats* HeartbeatResponse::mutable_node_stats() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::flex::NodeStats* _msg = _internal_mutable_node_stats();
  // @@protoc_insertion_point(field_mutable:flex.HeartbeatResponse.node_stats)
  return _msg;
}
inline void HeartbeatResponse::set_allocated_node_stats(::flex::NodeStats* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.node_stats_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.node_stats_ = reinterpret_cast<::flex::NodeStats*>(value);
  // @@protoc_insertion_point(field_set_allocated:flex.HeartbeatResponse.node_stats)
}

// -------------------------------------------------------------------

// NodeStats

// .google.protobuf.Timestamp timestamp = 1;
inline bool NodeStats::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& NodeStats::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& NodeStats::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.NodeStats.timestamp)
  return _internal_timestamp();
}
inline void NodeStats::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.NodeStats.timestamp)
}
inline ::google::protobuf::Timestamp* NodeStats::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* NodeStats::unsafe_arena_release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.NodeStats.timestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* NodeStats::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.timestamp_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* NodeStats::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:flex.NodeStats.timestamp)
  return _msg;
}
inline void NodeStats::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:flex.NodeStats.timestamp)
}

// int64 active_requests = 2;
inline void NodeStats::clear_active_requests() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.active_requests_ = ::int64_t{0};
}
inline ::int64_t NodeStats::active_requests() const {
  // @@protoc_insertion_point(field_get:flex.NodeStats.active_requests)
  return _internal_active_requests();
}
inline void NodeStats::set_active_requests(::int64_t value) {
  _internal_set_active_requests(value);
  // @@protoc_insertion_point(field_set:flex.NodeStats.active_requests)
}
inline ::int64_t NodeStats::_internal_active_requests() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.active_requests_;
}
inline void NodeStats::_internal_set_active_requests(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.active_requests_ = value;
}

// -------------------------------------------------------------------

// SubmitWorkRequest

// .flex.WorkRequest request = 1;
inline bool SubmitWorkRequest::has_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.request_ != nullptr);
  return value;
}
inline void SubmitWorkRequest::clear_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.request_ != nullptr) _impl_.request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::flex::WorkRequest& SubmitWorkRequest::_internal_request() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::flex::WorkRequest* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::flex::WorkRequest&>(::flex::_WorkRequest_default_instance_);
}
inline const ::flex::WorkRequest& SubmitWorkRequest::request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.SubmitWorkRequest.request)
  return _internal_request();
}
inline void SubmitWorkRequest::unsafe_arena_set_allocated_request(::flex::WorkRequest* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = reinterpret_cast<::flex::WorkRequest*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.SubmitWorkRequest.request)
}
inline ::flex::WorkRequest* SubmitWorkRequest::release_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::flex::WorkRequest* released = _impl_.request_;
  _impl_.request_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::flex::WorkRequest* SubmitWorkRequest::unsafe_arena_release_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.SubmitWorkRequest.request)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::flex::WorkRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::flex::WorkRequest* SubmitWorkRequest::_internal_mutable_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.request_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::flex::WorkRequest>(GetArena());
    _impl_.request_ = reinterpret_cast<::flex::WorkRequest*>(p);
  }
  return _impl_.request_;
}
inline ::flex::WorkRequest* SubmitWorkRequest::mutable_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::flex::WorkRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:flex.SubmitWorkRequest.request)
  return _msg;
}
inline void SubmitWorkRequest::set_allocated_request(::flex::WorkRequest* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.request_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.request_ = reinterpret_cast<::flex::WorkRequest*>(value);
  // @@protoc_insertion_point(field_set_allocated:flex.SubmitWorkRequest.request)
}

// -------------------------------------------------------------------

// SubmitWorkResponse

// .flex.Work work = 1;
inline bool SubmitWorkResponse::has_work() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.work_ != nullptr);
  return value;
}
inline void SubmitWorkResponse::clear_work() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.work_ != nullptr) _impl_.work_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::flex::Work& SubmitWorkResponse::_internal_work() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::flex::Work* p = _impl_.work_;
  return p != nullptr ? *p : reinterpret_cast<const ::flex::Work&>(::flex::_Work_default_instance_);
}
inline const ::flex::Work& SubmitWorkResponse::work() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.SubmitWorkResponse.work)
  return _internal_work();
}
inline void SubmitWorkResponse::unsafe_arena_set_allocated_work(::flex::Work* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.work_);
  }
  _impl_.work_ = reinterpret_cast<::flex::Work*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.SubmitWorkResponse.work)
}
inline ::flex::Work* SubmitWorkResponse::release_work() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::flex::Work* released = _impl_.work_;
  _impl_.work_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::flex::Work* SubmitWorkResponse::unsafe_arena_release_work() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.SubmitWorkResponse.work)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::flex::Work* temp = _impl_.work_;
  _impl_.work_ = nullptr;
  return temp;
}
inline ::flex::Work* SubmitWorkResponse::_internal_mutable_work() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.work_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::flex::Work>(GetArena());
    _impl_.work_ = reinterpret_cast<::flex::Work*>(p);
  }
  return _impl_.work_;
}
inline ::flex::Work* SubmitWorkResponse::mutable_work() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::flex::Work* _msg = _internal_mutable_work();
  // @@protoc_insertion_point(field_mutable:flex.SubmitWorkResponse.work)
  return _msg;
}
inline void SubmitWorkResponse::set_allocated_work(::flex::Work* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.work_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.work_ = reinterpret_cast<::flex::Work*>(value);
  // @@protoc_insertion_point(field_set_allocated:flex.SubmitWorkResponse.work)
}

// -------------------------------------------------------------------

// UpdateWorkRequest

// string job_id = 1;
inline void UpdateWorkRequest::clear_job_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& UpdateWorkRequest::job_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.UpdateWorkRequest.job_id)
  return _internal_job_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateWorkRequest::set_job_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.UpdateWorkRequest.job_id)
}
inline std::string* UpdateWorkRequest::mutable_job_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:flex.UpdateWorkRequest.job_id)
  return _s;
}
inline const std::string& UpdateWorkRequest::_internal_job_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.job_id_.Get();
}
inline void UpdateWorkRequest::_internal_set_job_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_id_.Set(value, GetArena());
}
inline std::string* UpdateWorkRequest::_internal_mutable_job_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.job_id_.Mutable( GetArena());
}
inline std::string* UpdateWorkRequest::release_job_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.UpdateWorkRequest.job_id)
  return _impl_.job_id_.Release();
}
inline void UpdateWorkRequest::set_allocated_job_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.UpdateWorkRequest.job_id)
}

// string request_id = 2;
inline void UpdateWorkRequest::clear_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& UpdateWorkRequest::request_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.UpdateWorkRequest.request_id)
  return _internal_request_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateWorkRequest::set_request_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.UpdateWorkRequest.request_id)
}
inline std::string* UpdateWorkRequest::mutable_request_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:flex.UpdateWorkRequest.request_id)
  return _s;
}
inline const std::string& UpdateWorkRequest::_internal_request_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.request_id_.Get();
}
inline void UpdateWorkRequest::_internal_set_request_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.Set(value, GetArena());
}
inline std::string* UpdateWorkRequest::_internal_mutable_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.request_id_.Mutable( GetArena());
}
inline std::string* UpdateWorkRequest::release_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.UpdateWorkRequest.request_id)
  return _impl_.request_id_.Release();
}
inline void UpdateWorkRequest::set_allocated_request_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.UpdateWorkRequest.request_id)
}

// .flex.UpdateWorkRequest.NewState new_state = 3;
inline void UpdateWorkRequest::clear_new_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_state_ = 0;
}
inline ::flex::UpdateWorkRequest_NewState UpdateWorkRequest::new_state() const {
  // @@protoc_insertion_point(field_get:flex.UpdateWorkRequest.new_state)
  return _internal_new_state();
}
inline void UpdateWorkRequest::set_new_state(::flex::UpdateWorkRequest_NewState value) {
  _internal_set_new_state(value);
  // @@protoc_insertion_point(field_set:flex.UpdateWorkRequest.new_state)
}
inline ::flex::UpdateWorkRequest_NewState UpdateWorkRequest::_internal_new_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::flex::UpdateWorkRequest_NewState>(_impl_.new_state_);
}
inline void UpdateWorkRequest::_internal_set_new_state(::flex::UpdateWorkRequest_NewState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_state_ = value;
}

// -------------------------------------------------------------------

// UpdateWorkResponse

// .flex.Work work = 1;
inline bool UpdateWorkResponse::has_work() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.work_ != nullptr);
  return value;
}
inline void UpdateWorkResponse::clear_work() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.work_ != nullptr) _impl_.work_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::flex::Work& UpdateWorkResponse::_internal_work() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::flex::Work* p = _impl_.work_;
  return p != nullptr ? *p : reinterpret_cast<const ::flex::Work&>(::flex::_Work_default_instance_);
}
inline const ::flex::Work& UpdateWorkResponse::work() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.UpdateWorkResponse.work)
  return _internal_work();
}
inline void UpdateWorkResponse::unsafe_arena_set_allocated_work(::flex::Work* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.work_);
  }
  _impl_.work_ = reinterpret_cast<::flex::Work*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.UpdateWorkResponse.work)
}
inline ::flex::Work* UpdateWorkResponse::release_work() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::flex::Work* released = _impl_.work_;
  _impl_.work_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::flex::Work* UpdateWorkResponse::unsafe_arena_release_work() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.UpdateWorkResponse.work)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::flex::Work* temp = _impl_.work_;
  _impl_.work_ = nullptr;
  return temp;
}
inline ::flex::Work* UpdateWorkResponse::_internal_mutable_work() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.work_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::flex::Work>(GetArena());
    _impl_.work_ = reinterpret_cast<::flex::Work*>(p);
  }
  return _impl_.work_;
}
inline ::flex::Work* UpdateWorkResponse::mutable_work() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::flex::Work* _msg = _internal_mutable_work();
  // @@protoc_insertion_point(field_mutable:flex.UpdateWorkResponse.work)
  return _msg;
}
inline void UpdateWorkResponse::set_allocated_work(::flex::Work* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.work_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.work_ = reinterpret_cast<::flex::Work*>(value);
  // @@protoc_insertion_point(field_set_allocated:flex.UpdateWorkResponse.work)
}

// -------------------------------------------------------------------

// BulkUpdateWorkRequest

// .flex.BulkUpdateWorkRequest.NewState new_state = 1;
inline void BulkUpdateWorkRequest::clear_new_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_state_ = 0;
}
inline ::flex::BulkUpdateWorkRequest_NewState BulkUpdateWorkRequest::new_state() const {
  // @@protoc_insertion_point(field_get:flex.BulkUpdateWorkRequest.new_state)
  return _internal_new_state();
}
inline void BulkUpdateWorkRequest::set_new_state(::flex::BulkUpdateWorkRequest_NewState value) {
  _internal_set_new_state(value);
  // @@protoc_insertion_point(field_set:flex.BulkUpdateWorkRequest.new_state)
}
inline ::flex::BulkUpdateWorkRequest_NewState BulkUpdateWorkRequest::_internal_new_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::flex::BulkUpdateWorkRequest_NewState>(_impl_.new_state_);
}
inline void BulkUpdateWorkRequest::_internal_set_new_state(::flex::BulkUpdateWorkRequest_NewState value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_state_ = value;
}

// -------------------------------------------------------------------

// BulkUpdateWorkResponse

// bool success = 1;
inline void BulkUpdateWorkResponse::clear_success() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = false;
}
inline bool BulkUpdateWorkResponse::success() const {
  // @@protoc_insertion_point(field_get:flex.BulkUpdateWorkResponse.success)
  return _internal_success();
}
inline void BulkUpdateWorkResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:flex.BulkUpdateWorkResponse.success)
}
inline bool BulkUpdateWorkResponse::_internal_success() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.success_;
}
inline void BulkUpdateWorkResponse::_internal_set_success(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.success_ = value;
}

// string message = 2;
inline void BulkUpdateWorkResponse::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& BulkUpdateWorkResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.BulkUpdateWorkResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BulkUpdateWorkResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.BulkUpdateWorkResponse.message)
}
inline std::string* BulkUpdateWorkResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:flex.BulkUpdateWorkResponse.message)
  return _s;
}
inline const std::string& BulkUpdateWorkResponse::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void BulkUpdateWorkResponse::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* BulkUpdateWorkResponse::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* BulkUpdateWorkResponse::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.BulkUpdateWorkResponse.message)
  return _impl_.message_.Release();
}
inline void BulkUpdateWorkResponse::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.BulkUpdateWorkResponse.message)
}

// -------------------------------------------------------------------

// WorkRequest_Segment

// int64 offset_start = 1;
inline void WorkRequest_Segment::clear_offset_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_start_ = ::int64_t{0};
}
inline ::int64_t WorkRequest_Segment::offset_start() const {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.Segment.offset_start)
  return _internal_offset_start();
}
inline void WorkRequest_Segment::set_offset_start(::int64_t value) {
  _internal_set_offset_start(value);
  // @@protoc_insertion_point(field_set:flex.WorkRequest.Segment.offset_start)
}
inline ::int64_t WorkRequest_Segment::_internal_offset_start() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_start_;
}
inline void WorkRequest_Segment::_internal_set_offset_start(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_start_ = value;
}

// int64 offset_stop = 2;
inline void WorkRequest_Segment::clear_offset_stop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_stop_ = ::int64_t{0};
}
inline ::int64_t WorkRequest_Segment::offset_stop() const {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.Segment.offset_stop)
  return _internal_offset_stop();
}
inline void WorkRequest_Segment::set_offset_stop(::int64_t value) {
  _internal_set_offset_stop(value);
  // @@protoc_insertion_point(field_set:flex.WorkRequest.Segment.offset_stop)
}
inline ::int64_t WorkRequest_Segment::_internal_offset_stop() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_stop_;
}
inline void WorkRequest_Segment::_internal_set_offset_stop(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_stop_ = value;
}

// int32 parts_start = 3;
inline void WorkRequest_Segment::clear_parts_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parts_start_ = 0;
}
inline ::int32_t WorkRequest_Segment::parts_start() const {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.Segment.parts_start)
  return _internal_parts_start();
}
inline void WorkRequest_Segment::set_parts_start(::int32_t value) {
  _internal_set_parts_start(value);
  // @@protoc_insertion_point(field_set:flex.WorkRequest.Segment.parts_start)
}
inline ::int32_t WorkRequest_Segment::_internal_parts_start() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parts_start_;
}
inline void WorkRequest_Segment::_internal_set_parts_start(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parts_start_ = value;
}

// int32 parts_stop = 4;
inline void WorkRequest_Segment::clear_parts_stop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parts_stop_ = 0;
}
inline ::int32_t WorkRequest_Segment::parts_stop() const {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.Segment.parts_stop)
  return _internal_parts_stop();
}
inline void WorkRequest_Segment::set_parts_stop(::int32_t value) {
  _internal_set_parts_stop(value);
  // @@protoc_insertion_point(field_set:flex.WorkRequest.Segment.parts_stop)
}
inline ::int32_t WorkRequest_Segment::_internal_parts_stop() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parts_stop_;
}
inline void WorkRequest_Segment::_internal_set_parts_stop(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parts_stop_ = value;
}

// -------------------------------------------------------------------

// WorkRequest

// string job_id = 1;
inline void WorkRequest::clear_job_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& WorkRequest::job_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.job_id)
  return _internal_job_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorkRequest::set_job_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.WorkRequest.job_id)
}
inline std::string* WorkRequest::mutable_job_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:flex.WorkRequest.job_id)
  return _s;
}
inline const std::string& WorkRequest::_internal_job_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.job_id_.Get();
}
inline void WorkRequest::_internal_set_job_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_id_.Set(value, GetArena());
}
inline std::string* WorkRequest::_internal_mutable_job_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.job_id_.Mutable( GetArena());
}
inline std::string* WorkRequest::release_job_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.WorkRequest.job_id)
  return _impl_.job_id_.Release();
}
inline void WorkRequest::set_allocated_job_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.WorkRequest.job_id)
}

// string request_id = 2;
inline void WorkRequest::clear_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& WorkRequest::request_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.request_id)
  return _internal_request_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorkRequest::set_request_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.WorkRequest.request_id)
}
inline std::string* WorkRequest::mutable_request_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:flex.WorkRequest.request_id)
  return _s;
}
inline const std::string& WorkRequest::_internal_request_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.request_id_.Get();
}
inline void WorkRequest::_internal_set_request_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.Set(value, GetArena());
}
inline std::string* WorkRequest::_internal_mutable_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.request_id_.Mutable( GetArena());
}
inline std::string* WorkRequest::release_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.WorkRequest.request_id)
  return _impl_.request_id_.Release();
}
inline void WorkRequest::set_allocated_request_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.WorkRequest.request_id)
}

// string external_id = 3;
inline void WorkRequest::clear_external_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.external_id_.ClearToEmpty();
}
inline const std::string& WorkRequest::external_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.external_id)
  return _internal_external_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorkRequest::set_external_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.external_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.WorkRequest.external_id)
}
inline std::string* WorkRequest::mutable_external_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_external_id();
  // @@protoc_insertion_point(field_mutable:flex.WorkRequest.external_id)
  return _s;
}
inline const std::string& WorkRequest::_internal_external_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.external_id_.Get();
}
inline void WorkRequest::_internal_set_external_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.external_id_.Set(value, GetArena());
}
inline std::string* WorkRequest::_internal_mutable_external_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.external_id_.Mutable( GetArena());
}
inline std::string* WorkRequest::release_external_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.WorkRequest.external_id)
  return _impl_.external_id_.Release();
}
inline void WorkRequest::set_allocated_external_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.external_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.external_id_.IsDefault()) {
    _impl_.external_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.WorkRequest.external_id)
}

// string path = 4;
inline void WorkRequest::clear_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.ClearToEmpty();
}
inline const std::string& WorkRequest::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorkRequest::set_path(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.WorkRequest.path)
}
inline std::string* WorkRequest::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:flex.WorkRequest.path)
  return _s;
}
inline const std::string& WorkRequest::_internal_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.path_.Get();
}
inline void WorkRequest::_internal_set_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.Set(value, GetArena());
}
inline std::string* WorkRequest::_internal_mutable_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* WorkRequest::release_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.WorkRequest.path)
  return _impl_.path_.Release();
}
inline void WorkRequest::set_allocated_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.WorkRequest.path)
}

// .flex.WorkRequest.Segment segment = 5;
inline bool WorkRequest::has_segment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.segment_ != nullptr);
  return value;
}
inline void WorkRequest::clear_segment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.segment_ != nullptr) _impl_.segment_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::flex::WorkRequest_Segment& WorkRequest::_internal_segment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::flex::WorkRequest_Segment* p = _impl_.segment_;
  return p != nullptr ? *p : reinterpret_cast<const ::flex::WorkRequest_Segment&>(::flex::_WorkRequest_Segment_default_instance_);
}
inline const ::flex::WorkRequest_Segment& WorkRequest::segment() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.segment)
  return _internal_segment();
}
inline void WorkRequest::unsafe_arena_set_allocated_segment(::flex::WorkRequest_Segment* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.segment_);
  }
  _impl_.segment_ = reinterpret_cast<::flex::WorkRequest_Segment*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.WorkRequest.segment)
}
inline ::flex::WorkRequest_Segment* WorkRequest::release_segment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::flex::WorkRequest_Segment* released = _impl_.segment_;
  _impl_.segment_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::flex::WorkRequest_Segment* WorkRequest::unsafe_arena_release_segment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.WorkRequest.segment)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::flex::WorkRequest_Segment* temp = _impl_.segment_;
  _impl_.segment_ = nullptr;
  return temp;
}
inline ::flex::WorkRequest_Segment* WorkRequest::_internal_mutable_segment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.segment_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::flex::WorkRequest_Segment>(GetArena());
    _impl_.segment_ = reinterpret_cast<::flex::WorkRequest_Segment*>(p);
  }
  return _impl_.segment_;
}
inline ::flex::WorkRequest_Segment* WorkRequest::mutable_segment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::flex::WorkRequest_Segment* _msg = _internal_mutable_segment();
  // @@protoc_insertion_point(field_mutable:flex.WorkRequest.segment)
  return _msg;
}
inline void WorkRequest::set_allocated_segment(::flex::WorkRequest_Segment* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.segment_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.segment_ = reinterpret_cast<::flex::WorkRequest_Segment*>(value);
  // @@protoc_insertion_point(field_set_allocated:flex.WorkRequest.segment)
}

// uint32 remote_storage_target = 6;
inline void WorkRequest::clear_remote_storage_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_storage_target_ = 0u;
}
inline ::uint32_t WorkRequest::remote_storage_target() const {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.remote_storage_target)
  return _internal_remote_storage_target();
}
inline void WorkRequest::set_remote_storage_target(::uint32_t value) {
  _internal_set_remote_storage_target(value);
  // @@protoc_insertion_point(field_set:flex.WorkRequest.remote_storage_target)
}
inline ::uint32_t WorkRequest::_internal_remote_storage_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.remote_storage_target_;
}
inline void WorkRequest::_internal_set_remote_storage_target(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_storage_target_ = value;
}

// .flex.MockJob mock = 10;
inline bool WorkRequest::has_mock() const {
  return Type_case() == kMock;
}
inline bool WorkRequest::_internal_has_mock() const {
  return Type_case() == kMock;
}
inline void WorkRequest::set_has_mock() {
  _impl_._oneof_case_[0] = kMock;
}
inline void WorkRequest::clear_mock() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (Type_case() == kMock) {
    if (GetArena() == nullptr) {
      delete _impl_.Type_.mock_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.Type_.mock_);
    }
    clear_has_Type();
  }
}
inline ::flex::MockJob* WorkRequest::release_mock() {
  // @@protoc_insertion_point(field_release:flex.WorkRequest.mock)
  if (Type_case() == kMock) {
    clear_has_Type();
    auto* temp = _impl_.Type_.mock_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Type_.mock_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flex::MockJob& WorkRequest::_internal_mock() const {
  return Type_case() == kMock ? *_impl_.Type_.mock_ : reinterpret_cast<::flex::MockJob&>(::flex::_MockJob_default_instance_);
}
inline const ::flex::MockJob& WorkRequest::mock() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.mock)
  return _internal_mock();
}
inline ::flex::MockJob* WorkRequest::unsafe_arena_release_mock() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.WorkRequest.mock)
  if (Type_case() == kMock) {
    clear_has_Type();
    auto* temp = _impl_.Type_.mock_;
    _impl_.Type_.mock_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkRequest::unsafe_arena_set_allocated_mock(::flex::MockJob* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_Type();
  if (value) {
    set_has_mock();
    _impl_.Type_.mock_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.WorkRequest.mock)
}
inline ::flex::MockJob* WorkRequest::_internal_mutable_mock() {
  if (Type_case() != kMock) {
    clear_Type();
    set_has_mock();
    _impl_.Type_.mock_ =
        ::google::protobuf::Message::DefaultConstruct<::flex::MockJob>(GetArena());
  }
  return _impl_.Type_.mock_;
}
inline ::flex::MockJob* WorkRequest::mutable_mock() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::flex::MockJob* _msg = _internal_mutable_mock();
  // @@protoc_insertion_point(field_mutable:flex.WorkRequest.mock)
  return _msg;
}

// .flex.SyncJob sync = 11;
inline bool WorkRequest::has_sync() const {
  return Type_case() == kSync;
}
inline bool WorkRequest::_internal_has_sync() const {
  return Type_case() == kSync;
}
inline void WorkRequest::set_has_sync() {
  _impl_._oneof_case_[0] = kSync;
}
inline void WorkRequest::clear_sync() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (Type_case() == kSync) {
    if (GetArena() == nullptr) {
      delete _impl_.Type_.sync_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.Type_.sync_);
    }
    clear_has_Type();
  }
}
inline ::flex::SyncJob* WorkRequest::release_sync() {
  // @@protoc_insertion_point(field_release:flex.WorkRequest.sync)
  if (Type_case() == kSync) {
    clear_has_Type();
    auto* temp = _impl_.Type_.sync_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.Type_.sync_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flex::SyncJob& WorkRequest::_internal_sync() const {
  return Type_case() == kSync ? *_impl_.Type_.sync_ : reinterpret_cast<::flex::SyncJob&>(::flex::_SyncJob_default_instance_);
}
inline const ::flex::SyncJob& WorkRequest::sync() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.sync)
  return _internal_sync();
}
inline ::flex::SyncJob* WorkRequest::unsafe_arena_release_sync() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.WorkRequest.sync)
  if (Type_case() == kSync) {
    clear_has_Type();
    auto* temp = _impl_.Type_.sync_;
    _impl_.Type_.sync_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WorkRequest::unsafe_arena_set_allocated_sync(::flex::SyncJob* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_Type();
  if (value) {
    set_has_sync();
    _impl_.Type_.sync_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.WorkRequest.sync)
}
inline ::flex::SyncJob* WorkRequest::_internal_mutable_sync() {
  if (Type_case() != kSync) {
    clear_Type();
    set_has_sync();
    _impl_.Type_.sync_ =
        ::google::protobuf::Message::DefaultConstruct<::flex::SyncJob>(GetArena());
  }
  return _impl_.Type_.sync_;
}
inline ::flex::SyncJob* WorkRequest::mutable_sync() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::flex::SyncJob* _msg = _internal_mutable_sync();
  // @@protoc_insertion_point(field_mutable:flex.WorkRequest.sync)
  return _msg;
}

// bool job_builder = 7;
inline void WorkRequest::clear_job_builder() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_builder_ = false;
}
inline bool WorkRequest::job_builder() const {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.job_builder)
  return _internal_job_builder();
}
inline void WorkRequest::set_job_builder(bool value) {
  _internal_set_job_builder(value);
  // @@protoc_insertion_point(field_set:flex.WorkRequest.job_builder)
}
inline bool WorkRequest::_internal_job_builder() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.job_builder_;
}
inline void WorkRequest::_internal_set_job_builder(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_builder_ = value;
}

// bool stub_local = 8;
inline void WorkRequest::clear_stub_local() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stub_local_ = false;
}
inline bool WorkRequest::stub_local() const {
  // @@protoc_insertion_point(field_get:flex.WorkRequest.stub_local)
  return _internal_stub_local();
}
inline void WorkRequest::set_stub_local(bool value) {
  _internal_set_stub_local(value);
  // @@protoc_insertion_point(field_set:flex.WorkRequest.stub_local)
}
inline bool WorkRequest::_internal_stub_local() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stub_local_;
}
inline void WorkRequest::_internal_set_stub_local(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stub_local_ = value;
}

inline bool WorkRequest::has_Type() const {
  return Type_case() != TYPE_NOT_SET;
}
inline void WorkRequest::clear_has_Type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline WorkRequest::TypeCase WorkRequest::Type_case() const {
  return WorkRequest::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MockJob

// int32 num_test_segments = 1;
inline void MockJob::clear_num_test_segments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_test_segments_ = 0;
}
inline ::int32_t MockJob::num_test_segments() const {
  // @@protoc_insertion_point(field_get:flex.MockJob.num_test_segments)
  return _internal_num_test_segments();
}
inline void MockJob::set_num_test_segments(::int32_t value) {
  _internal_set_num_test_segments(value);
  // @@protoc_insertion_point(field_set:flex.MockJob.num_test_segments)
}
inline ::int32_t MockJob::_internal_num_test_segments() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_test_segments_;
}
inline void MockJob::_internal_set_num_test_segments(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_test_segments_ = value;
}

// int64 file_size = 2;
inline void MockJob::clear_file_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_size_ = ::int64_t{0};
}
inline ::int64_t MockJob::file_size() const {
  // @@protoc_insertion_point(field_get:flex.MockJob.file_size)
  return _internal_file_size();
}
inline void MockJob::set_file_size(::int64_t value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:flex.MockJob.file_size)
}
inline ::int64_t MockJob::_internal_file_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.file_size_;
}
inline void MockJob::_internal_set_file_size(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_size_ = value;
}

// string external_id = 3;
inline void MockJob::clear_external_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.external_id_.ClearToEmpty();
}
inline const std::string& MockJob::external_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.MockJob.external_id)
  return _internal_external_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MockJob::set_external_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.external_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.MockJob.external_id)
}
inline std::string* MockJob::mutable_external_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_external_id();
  // @@protoc_insertion_point(field_mutable:flex.MockJob.external_id)
  return _s;
}
inline const std::string& MockJob::_internal_external_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.external_id_.Get();
}
inline void MockJob::_internal_set_external_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.external_id_.Set(value, GetArena());
}
inline std::string* MockJob::_internal_mutable_external_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.external_id_.Mutable( GetArena());
}
inline std::string* MockJob::release_external_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.MockJob.external_id)
  return _impl_.external_id_.Release();
}
inline void MockJob::set_allocated_external_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.external_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.external_id_.IsDefault()) {
    _impl_.external_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.MockJob.external_id)
}

// bool should_fail = 4;
inline void MockJob::clear_should_fail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.should_fail_ = false;
}
inline bool MockJob::should_fail() const {
  // @@protoc_insertion_point(field_get:flex.MockJob.should_fail)
  return _internal_should_fail();
}
inline void MockJob::set_should_fail(bool value) {
  _internal_set_should_fail(value);
  // @@protoc_insertion_point(field_set:flex.MockJob.should_fail)
}
inline bool MockJob::_internal_should_fail() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.should_fail_;
}
inline void MockJob::_internal_set_should_fail(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.should_fail_ = value;
}

// bool can_retry = 5;
inline void MockJob::clear_can_retry() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.can_retry_ = false;
}
inline bool MockJob::can_retry() const {
  // @@protoc_insertion_point(field_get:flex.MockJob.can_retry)
  return _internal_can_retry();
}
inline void MockJob::set_can_retry(bool value) {
  _internal_set_can_retry(value);
  // @@protoc_insertion_point(field_set:flex.MockJob.can_retry)
}
inline bool MockJob::_internal_can_retry() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.can_retry_;
}
inline void MockJob::_internal_set_can_retry(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.can_retry_ = value;
}

// -------------------------------------------------------------------

// SyncJob

// .flex.SyncJob.Operation operation = 1;
inline void SyncJob::clear_operation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_ = 0;
}
inline ::flex::SyncJob_Operation SyncJob::operation() const {
  // @@protoc_insertion_point(field_get:flex.SyncJob.operation)
  return _internal_operation();
}
inline void SyncJob::set_operation(::flex::SyncJob_Operation value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:flex.SyncJob.operation)
}
inline ::flex::SyncJob_Operation SyncJob::_internal_operation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::flex::SyncJob_Operation>(_impl_.operation_);
}
inline void SyncJob::_internal_set_operation(::flex::SyncJob_Operation value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operation_ = value;
}

// bool overwrite = 2;
inline void SyncJob::clear_overwrite() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.overwrite_ = false;
}
inline bool SyncJob::overwrite() const {
  // @@protoc_insertion_point(field_get:flex.SyncJob.overwrite)
  return _internal_overwrite();
}
inline void SyncJob::set_overwrite(bool value) {
  _internal_set_overwrite(value);
  // @@protoc_insertion_point(field_set:flex.SyncJob.overwrite)
}
inline bool SyncJob::_internal_overwrite() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.overwrite_;
}
inline void SyncJob::_internal_set_overwrite(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.overwrite_ = value;
}

// string remote_path = 3;
inline void SyncJob::clear_remote_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_path_.ClearToEmpty();
}
inline const std::string& SyncJob::remote_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.SyncJob.remote_path)
  return _internal_remote_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SyncJob::set_remote_path(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.SyncJob.remote_path)
}
inline std::string* SyncJob::mutable_remote_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_remote_path();
  // @@protoc_insertion_point(field_mutable:flex.SyncJob.remote_path)
  return _s;
}
inline const std::string& SyncJob::_internal_remote_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.remote_path_.Get();
}
inline void SyncJob::_internal_set_remote_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_path_.Set(value, GetArena());
}
inline std::string* SyncJob::_internal_mutable_remote_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.remote_path_.Mutable( GetArena());
}
inline std::string* SyncJob::release_remote_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.SyncJob.remote_path)
  return _impl_.remote_path_.Release();
}
inline void SyncJob::set_allocated_remote_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remote_path_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.remote_path_.IsDefault()) {
    _impl_.remote_path_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.SyncJob.remote_path)
}

// bool flatten = 5;
inline void SyncJob::clear_flatten() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.flatten_ = false;
}
inline bool SyncJob::flatten() const {
  // @@protoc_insertion_point(field_get:flex.SyncJob.flatten)
  return _internal_flatten();
}
inline void SyncJob::set_flatten(bool value) {
  _internal_set_flatten(value);
  // @@protoc_insertion_point(field_set:flex.SyncJob.flatten)
}
inline bool SyncJob::_internal_flatten() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.flatten_;
}
inline void SyncJob::_internal_set_flatten(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.flatten_ = value;
}

// -------------------------------------------------------------------

// Work_Status

// .flex.Work.State state = 1;
inline void Work_Status::clear_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = 0;
}
inline ::flex::Work_State Work_Status::state() const {
  // @@protoc_insertion_point(field_get:flex.Work.Status.state)
  return _internal_state();
}
inline void Work_Status::set_state(::flex::Work_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:flex.Work.Status.state)
}
inline ::flex::Work_State Work_Status::_internal_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::flex::Work_State>(_impl_.state_);
}
inline void Work_Status::_internal_set_state(::flex::Work_State value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.state_ = value;
}

// string message = 2;
inline void Work_Status::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Work_Status::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.Work.Status.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Work_Status::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.Work.Status.message)
}
inline std::string* Work_Status::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:flex.Work.Status.message)
  return _s;
}
inline const std::string& Work_Status::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void Work_Status::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* Work_Status::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* Work_Status::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.Work.Status.message)
  return _impl_.message_.Release();
}
inline void Work_Status::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.Work.Status.message)
}

// -------------------------------------------------------------------

// Work_Part

// int32 part_number = 1;
inline void Work_Part::clear_part_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.part_number_ = 0;
}
inline ::int32_t Work_Part::part_number() const {
  // @@protoc_insertion_point(field_get:flex.Work.Part.part_number)
  return _internal_part_number();
}
inline void Work_Part::set_part_number(::int32_t value) {
  _internal_set_part_number(value);
  // @@protoc_insertion_point(field_set:flex.Work.Part.part_number)
}
inline ::int32_t Work_Part::_internal_part_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.part_number_;
}
inline void Work_Part::_internal_set_part_number(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.part_number_ = value;
}

// int64 offset_start = 2;
inline void Work_Part::clear_offset_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_start_ = ::int64_t{0};
}
inline ::int64_t Work_Part::offset_start() const {
  // @@protoc_insertion_point(field_get:flex.Work.Part.offset_start)
  return _internal_offset_start();
}
inline void Work_Part::set_offset_start(::int64_t value) {
  _internal_set_offset_start(value);
  // @@protoc_insertion_point(field_set:flex.Work.Part.offset_start)
}
inline ::int64_t Work_Part::_internal_offset_start() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_start_;
}
inline void Work_Part::_internal_set_offset_start(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_start_ = value;
}

// int64 offset_stop = 3;
inline void Work_Part::clear_offset_stop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_stop_ = ::int64_t{0};
}
inline ::int64_t Work_Part::offset_stop() const {
  // @@protoc_insertion_point(field_get:flex.Work.Part.offset_stop)
  return _internal_offset_stop();
}
inline void Work_Part::set_offset_stop(::int64_t value) {
  _internal_set_offset_stop(value);
  // @@protoc_insertion_point(field_set:flex.Work.Part.offset_stop)
}
inline ::int64_t Work_Part::_internal_offset_stop() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.offset_stop_;
}
inline void Work_Part::_internal_set_offset_stop(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.offset_stop_ = value;
}

// string entity_tag = 4;
inline void Work_Part::clear_entity_tag() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_tag_.ClearToEmpty();
}
inline const std::string& Work_Part::entity_tag() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.Work.Part.entity_tag)
  return _internal_entity_tag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Work_Part::set_entity_tag(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_tag_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.Work.Part.entity_tag)
}
inline std::string* Work_Part::mutable_entity_tag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_entity_tag();
  // @@protoc_insertion_point(field_mutable:flex.Work.Part.entity_tag)
  return _s;
}
inline const std::string& Work_Part::_internal_entity_tag() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_tag_.Get();
}
inline void Work_Part::_internal_set_entity_tag(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_tag_.Set(value, GetArena());
}
inline std::string* Work_Part::_internal_mutable_entity_tag() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.entity_tag_.Mutable( GetArena());
}
inline std::string* Work_Part::release_entity_tag() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.Work.Part.entity_tag)
  return _impl_.entity_tag_.Release();
}
inline void Work_Part::set_allocated_entity_tag(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_tag_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.entity_tag_.IsDefault()) {
    _impl_.entity_tag_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.Work.Part.entity_tag)
}

// string checksum_sha256 = 5;
inline void Work_Part::clear_checksum_sha256() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.checksum_sha256_.ClearToEmpty();
}
inline const std::string& Work_Part::checksum_sha256() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.Work.Part.checksum_sha256)
  return _internal_checksum_sha256();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Work_Part::set_checksum_sha256(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.checksum_sha256_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.Work.Part.checksum_sha256)
}
inline std::string* Work_Part::mutable_checksum_sha256() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_checksum_sha256();
  // @@protoc_insertion_point(field_mutable:flex.Work.Part.checksum_sha256)
  return _s;
}
inline const std::string& Work_Part::_internal_checksum_sha256() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.checksum_sha256_.Get();
}
inline void Work_Part::_internal_set_checksum_sha256(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.checksum_sha256_.Set(value, GetArena());
}
inline std::string* Work_Part::_internal_mutable_checksum_sha256() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.checksum_sha256_.Mutable( GetArena());
}
inline std::string* Work_Part::release_checksum_sha256() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.Work.Part.checksum_sha256)
  return _impl_.checksum_sha256_.Release();
}
inline void Work_Part::set_allocated_checksum_sha256(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.checksum_sha256_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.checksum_sha256_.IsDefault()) {
    _impl_.checksum_sha256_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.Work.Part.checksum_sha256)
}

// bool completed = 6;
inline void Work_Part::clear_completed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.completed_ = false;
}
inline bool Work_Part::completed() const {
  // @@protoc_insertion_point(field_get:flex.Work.Part.completed)
  return _internal_completed();
}
inline void Work_Part::set_completed(bool value) {
  _internal_set_completed(value);
  // @@protoc_insertion_point(field_set:flex.Work.Part.completed)
}
inline bool Work_Part::_internal_completed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.completed_;
}
inline void Work_Part::_internal_set_completed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.completed_ = value;
}

// -------------------------------------------------------------------

// Work

// string path = 1;
inline void Work::clear_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.ClearToEmpty();
}
inline const std::string& Work::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.Work.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Work::set_path(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.Work.path)
}
inline std::string* Work::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:flex.Work.path)
  return _s;
}
inline const std::string& Work::_internal_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.path_.Get();
}
inline void Work::_internal_set_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.Set(value, GetArena());
}
inline std::string* Work::_internal_mutable_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* Work::release_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.Work.path)
  return _impl_.path_.Release();
}
inline void Work::set_allocated_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.Work.path)
}

// string job_id = 2;
inline void Work::clear_job_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_id_.ClearToEmpty();
}
inline const std::string& Work::job_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.Work.job_id)
  return _internal_job_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Work::set_job_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.Work.job_id)
}
inline std::string* Work::mutable_job_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_job_id();
  // @@protoc_insertion_point(field_mutable:flex.Work.job_id)
  return _s;
}
inline const std::string& Work::_internal_job_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.job_id_.Get();
}
inline void Work::_internal_set_job_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_id_.Set(value, GetArena());
}
inline std::string* Work::_internal_mutable_job_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.job_id_.Mutable( GetArena());
}
inline std::string* Work::release_job_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.Work.job_id)
  return _impl_.job_id_.Release();
}
inline void Work::set_allocated_job_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.job_id_.IsDefault()) {
    _impl_.job_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.Work.job_id)
}

// string request_id = 3;
inline void Work::clear_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.ClearToEmpty();
}
inline const std::string& Work::request_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.Work.request_id)
  return _internal_request_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Work::set_request_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.Work.request_id)
}
inline std::string* Work::mutable_request_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:flex.Work.request_id)
  return _s;
}
inline const std::string& Work::_internal_request_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.request_id_.Get();
}
inline void Work::_internal_set_request_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.Set(value, GetArena());
}
inline std::string* Work::_internal_mutable_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.request_id_.Mutable( GetArena());
}
inline std::string* Work::release_request_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.Work.request_id)
  return _impl_.request_id_.Release();
}
inline void Work::set_allocated_request_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.request_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.request_id_.IsDefault()) {
    _impl_.request_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.Work.request_id)
}

// .flex.Work.Status status = 4;
inline bool Work::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void Work::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::flex::Work_Status& Work::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::flex::Work_Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::flex::Work_Status&>(::flex::_Work_Status_default_instance_);
}
inline const ::flex::Work_Status& Work::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.Work.status)
  return _internal_status();
}
inline void Work::unsafe_arena_set_allocated_status(::flex::Work_Status* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::flex::Work_Status*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.Work.status)
}
inline ::flex::Work_Status* Work::release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::flex::Work_Status* released = _impl_.status_;
  _impl_.status_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::flex::Work_Status* Work::unsafe_arena_release_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.Work.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::flex::Work_Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::flex::Work_Status* Work::_internal_mutable_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.status_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::flex::Work_Status>(GetArena());
    _impl_.status_ = reinterpret_cast<::flex::Work_Status*>(p);
  }
  return _impl_.status_;
}
inline ::flex::Work_Status* Work::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::flex::Work_Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:flex.Work.status)
  return _msg;
}
inline void Work::set_allocated_status(::flex::Work_Status* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::flex::Work_Status*>(value);
  // @@protoc_insertion_point(field_set_allocated:flex.Work.status)
}

// repeated .flex.Work.Part parts = 5;
inline int Work::_internal_parts_size() const {
  return _internal_parts().size();
}
inline int Work::parts_size() const {
  return _internal_parts_size();
}
inline void Work::clear_parts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parts_.Clear();
}
inline ::flex::Work_Part* Work::mutable_parts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:flex.Work.parts)
  return _internal_mutable_parts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::flex::Work_Part>* Work::mutable_parts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:flex.Work.parts)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_parts();
}
inline const ::flex::Work_Part& Work::parts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.Work.parts)
  return _internal_parts().Get(index);
}
inline ::flex::Work_Part* Work::add_parts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::flex::Work_Part* _add = _internal_mutable_parts()->Add();
  // @@protoc_insertion_point(field_add:flex.Work.parts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::flex::Work_Part>& Work::parts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:flex.Work.parts)
  return _internal_parts();
}
inline const ::google::protobuf::RepeatedPtrField<::flex::Work_Part>&
Work::_internal_parts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parts_;
}
inline ::google::protobuf::RepeatedPtrField<::flex::Work_Part>*
Work::_internal_mutable_parts() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.parts_;
}

// bool job_builder = 6;
inline void Work::clear_job_builder() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_builder_ = false;
}
inline bool Work::job_builder() const {
  // @@protoc_insertion_point(field_get:flex.Work.job_builder)
  return _internal_job_builder();
}
inline void Work::set_job_builder(bool value) {
  _internal_set_job_builder(value);
  // @@protoc_insertion_point(field_set:flex.Work.job_builder)
}
inline bool Work::_internal_job_builder() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.job_builder_;
}
inline void Work::_internal_set_job_builder(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_builder_ = value;
}

// -------------------------------------------------------------------

// UpdateConfigRequest

// .flex.BeeRemoteNode bee_remote = 1;
inline bool UpdateConfigRequest::has_bee_remote() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bee_remote_ != nullptr);
  return value;
}
inline void UpdateConfigRequest::clear_bee_remote() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bee_remote_ != nullptr) _impl_.bee_remote_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::flex::BeeRemoteNode& UpdateConfigRequest::_internal_bee_remote() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::flex::BeeRemoteNode* p = _impl_.bee_remote_;
  return p != nullptr ? *p : reinterpret_cast<const ::flex::BeeRemoteNode&>(::flex::_BeeRemoteNode_default_instance_);
}
inline const ::flex::BeeRemoteNode& UpdateConfigRequest::bee_remote() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.UpdateConfigRequest.bee_remote)
  return _internal_bee_remote();
}
inline void UpdateConfigRequest::unsafe_arena_set_allocated_bee_remote(::flex::BeeRemoteNode* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.bee_remote_);
  }
  _impl_.bee_remote_ = reinterpret_cast<::flex::BeeRemoteNode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.UpdateConfigRequest.bee_remote)
}
inline ::flex::BeeRemoteNode* UpdateConfigRequest::release_bee_remote() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::flex::BeeRemoteNode* released = _impl_.bee_remote_;
  _impl_.bee_remote_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::flex::BeeRemoteNode* UpdateConfigRequest::unsafe_arena_release_bee_remote() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.UpdateConfigRequest.bee_remote)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::flex::BeeRemoteNode* temp = _impl_.bee_remote_;
  _impl_.bee_remote_ = nullptr;
  return temp;
}
inline ::flex::BeeRemoteNode* UpdateConfigRequest::_internal_mutable_bee_remote() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.bee_remote_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::flex::BeeRemoteNode>(GetArena());
    _impl_.bee_remote_ = reinterpret_cast<::flex::BeeRemoteNode*>(p);
  }
  return _impl_.bee_remote_;
}
inline ::flex::BeeRemoteNode* UpdateConfigRequest::mutable_bee_remote() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::flex::BeeRemoteNode* _msg = _internal_mutable_bee_remote();
  // @@protoc_insertion_point(field_mutable:flex.UpdateConfigRequest.bee_remote)
  return _msg;
}
inline void UpdateConfigRequest::set_allocated_bee_remote(::flex::BeeRemoteNode* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.bee_remote_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.bee_remote_ = reinterpret_cast<::flex::BeeRemoteNode*>(value);
  // @@protoc_insertion_point(field_set_allocated:flex.UpdateConfigRequest.bee_remote)
}

// repeated .flex.RemoteStorageTarget rsts = 2;
inline int UpdateConfigRequest::_internal_rsts_size() const {
  return _internal_rsts().size();
}
inline int UpdateConfigRequest::rsts_size() const {
  return _internal_rsts_size();
}
inline void UpdateConfigRequest::clear_rsts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rsts_.Clear();
}
inline ::flex::RemoteStorageTarget* UpdateConfigRequest::mutable_rsts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:flex.UpdateConfigRequest.rsts)
  return _internal_mutable_rsts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::flex::RemoteStorageTarget>* UpdateConfigRequest::mutable_rsts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:flex.UpdateConfigRequest.rsts)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_rsts();
}
inline const ::flex::RemoteStorageTarget& UpdateConfigRequest::rsts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.UpdateConfigRequest.rsts)
  return _internal_rsts().Get(index);
}
inline ::flex::RemoteStorageTarget* UpdateConfigRequest::add_rsts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::flex::RemoteStorageTarget* _add = _internal_mutable_rsts()->Add();
  // @@protoc_insertion_point(field_add:flex.UpdateConfigRequest.rsts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::flex::RemoteStorageTarget>& UpdateConfigRequest::rsts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:flex.UpdateConfigRequest.rsts)
  return _internal_rsts();
}
inline const ::google::protobuf::RepeatedPtrField<::flex::RemoteStorageTarget>&
UpdateConfigRequest::_internal_rsts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rsts_;
}
inline ::google::protobuf::RepeatedPtrField<::flex::RemoteStorageTarget>*
UpdateConfigRequest::_internal_mutable_rsts() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.rsts_;
}

// -------------------------------------------------------------------

// UpdateConfigResponse

// .flex.UpdateConfigResponse.Result result = 1;
inline void UpdateConfigResponse::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = 0;
}
inline ::flex::UpdateConfigResponse_Result UpdateConfigResponse::result() const {
  // @@protoc_insertion_point(field_get:flex.UpdateConfigResponse.result)
  return _internal_result();
}
inline void UpdateConfigResponse::set_result(::flex::UpdateConfigResponse_Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:flex.UpdateConfigResponse.result)
}
inline ::flex::UpdateConfigResponse_Result UpdateConfigResponse::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::flex::UpdateConfigResponse_Result>(_impl_.result_);
}
inline void UpdateConfigResponse::_internal_set_result(::flex::UpdateConfigResponse_Result value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// string message = 2;
inline void UpdateConfigResponse::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& UpdateConfigResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.UpdateConfigResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateConfigResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.UpdateConfigResponse.message)
}
inline std::string* UpdateConfigResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:flex.UpdateConfigResponse.message)
  return _s;
}
inline const std::string& UpdateConfigResponse::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void UpdateConfigResponse::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* UpdateConfigResponse::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* UpdateConfigResponse::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.UpdateConfigResponse.message)
  return _impl_.message_.Release();
}
inline void UpdateConfigResponse::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.UpdateConfigResponse.message)
}

// -------------------------------------------------------------------

// BeeRemoteNode

// string id = 1;
inline void BeeRemoteNode::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& BeeRemoteNode::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.BeeRemoteNode.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BeeRemoteNode::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.BeeRemoteNode.id)
}
inline std::string* BeeRemoteNode::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flex.BeeRemoteNode.id)
  return _s;
}
inline const std::string& BeeRemoteNode::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void BeeRemoteNode::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* BeeRemoteNode::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* BeeRemoteNode::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.BeeRemoteNode.id)
  return _impl_.id_.Release();
}
inline void BeeRemoteNode::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.BeeRemoteNode.id)
}

// string address = 2;
inline void BeeRemoteNode::clear_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.ClearToEmpty();
}
inline const std::string& BeeRemoteNode::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.BeeRemoteNode.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BeeRemoteNode::set_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.BeeRemoteNode.address)
}
inline std::string* BeeRemoteNode::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:flex.BeeRemoteNode.address)
  return _s;
}
inline const std::string& BeeRemoteNode::_internal_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.address_.Get();
}
inline void BeeRemoteNode::_internal_set_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.Set(value, GetArena());
}
inline std::string* BeeRemoteNode::_internal_mutable_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* BeeRemoteNode::release_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.BeeRemoteNode.address)
  return _impl_.address_.Release();
}
inline void BeeRemoteNode::set_allocated_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.BeeRemoteNode.address)
}

// -------------------------------------------------------------------

// RemoteStorageTarget_Policies

// int64 fast_start_max_size = 1;
inline void RemoteStorageTarget_Policies::clear_fast_start_max_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fast_start_max_size_ = ::int64_t{0};
}
inline ::int64_t RemoteStorageTarget_Policies::fast_start_max_size() const {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.Policies.fast_start_max_size)
  return _internal_fast_start_max_size();
}
inline void RemoteStorageTarget_Policies::set_fast_start_max_size(::int64_t value) {
  _internal_set_fast_start_max_size(value);
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.Policies.fast_start_max_size)
}
inline ::int64_t RemoteStorageTarget_Policies::_internal_fast_start_max_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fast_start_max_size_;
}
inline void RemoteStorageTarget_Policies::_internal_set_fast_start_max_size(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fast_start_max_size_ = value;
}

// -------------------------------------------------------------------

// RemoteStorageTarget_S3

// string endpoint_url = 1;
inline void RemoteStorageTarget_S3::clear_endpoint_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.endpoint_url_.ClearToEmpty();
}
inline const std::string& RemoteStorageTarget_S3::endpoint_url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.S3.endpoint_url)
  return _internal_endpoint_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoteStorageTarget_S3::set_endpoint_url(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.endpoint_url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.S3.endpoint_url)
}
inline std::string* RemoteStorageTarget_S3::mutable_endpoint_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_endpoint_url();
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.S3.endpoint_url)
  return _s;
}
inline const std::string& RemoteStorageTarget_S3::_internal_endpoint_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.endpoint_url_.Get();
}
inline void RemoteStorageTarget_S3::_internal_set_endpoint_url(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.endpoint_url_.Set(value, GetArena());
}
inline std::string* RemoteStorageTarget_S3::_internal_mutable_endpoint_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.endpoint_url_.Mutable( GetArena());
}
inline std::string* RemoteStorageTarget_S3::release_endpoint_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.S3.endpoint_url)
  return _impl_.endpoint_url_.Release();
}
inline void RemoteStorageTarget_S3::set_allocated_endpoint_url(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.endpoint_url_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.endpoint_url_.IsDefault()) {
    _impl_.endpoint_url_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.S3.endpoint_url)
}

// string partition_id = 2;
inline void RemoteStorageTarget_S3::clear_partition_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partition_id_.ClearToEmpty();
}
inline const std::string& RemoteStorageTarget_S3::partition_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.S3.partition_id)
  return _internal_partition_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoteStorageTarget_S3::set_partition_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partition_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.S3.partition_id)
}
inline std::string* RemoteStorageTarget_S3::mutable_partition_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_partition_id();
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.S3.partition_id)
  return _s;
}
inline const std::string& RemoteStorageTarget_S3::_internal_partition_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.partition_id_.Get();
}
inline void RemoteStorageTarget_S3::_internal_set_partition_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partition_id_.Set(value, GetArena());
}
inline std::string* RemoteStorageTarget_S3::_internal_mutable_partition_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.partition_id_.Mutable( GetArena());
}
inline std::string* RemoteStorageTarget_S3::release_partition_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.S3.partition_id)
  return _impl_.partition_id_.Release();
}
inline void RemoteStorageTarget_S3::set_allocated_partition_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partition_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.partition_id_.IsDefault()) {
    _impl_.partition_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.S3.partition_id)
}

// string region = 3;
inline void RemoteStorageTarget_S3::clear_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.region_.ClearToEmpty();
}
inline const std::string& RemoteStorageTarget_S3::region() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.S3.region)
  return _internal_region();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoteStorageTarget_S3::set_region(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.region_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.S3.region)
}
inline std::string* RemoteStorageTarget_S3::mutable_region() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.S3.region)
  return _s;
}
inline const std::string& RemoteStorageTarget_S3::_internal_region() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.region_.Get();
}
inline void RemoteStorageTarget_S3::_internal_set_region(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.region_.Set(value, GetArena());
}
inline std::string* RemoteStorageTarget_S3::_internal_mutable_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.region_.Mutable( GetArena());
}
inline std::string* RemoteStorageTarget_S3::release_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.S3.region)
  return _impl_.region_.Release();
}
inline void RemoteStorageTarget_S3::set_allocated_region(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.region_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.region_.IsDefault()) {
    _impl_.region_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.S3.region)
}

// string bucket = 4;
inline void RemoteStorageTarget_S3::clear_bucket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bucket_.ClearToEmpty();
}
inline const std::string& RemoteStorageTarget_S3::bucket() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.S3.bucket)
  return _internal_bucket();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoteStorageTarget_S3::set_bucket(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bucket_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.S3.bucket)
}
inline std::string* RemoteStorageTarget_S3::mutable_bucket() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bucket();
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.S3.bucket)
  return _s;
}
inline const std::string& RemoteStorageTarget_S3::_internal_bucket() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bucket_.Get();
}
inline void RemoteStorageTarget_S3::_internal_set_bucket(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bucket_.Set(value, GetArena());
}
inline std::string* RemoteStorageTarget_S3::_internal_mutable_bucket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.bucket_.Mutable( GetArena());
}
inline std::string* RemoteStorageTarget_S3::release_bucket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.S3.bucket)
  return _impl_.bucket_.Release();
}
inline void RemoteStorageTarget_S3::set_allocated_bucket(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bucket_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.bucket_.IsDefault()) {
    _impl_.bucket_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.S3.bucket)
}

// string access_key = 5;
inline void RemoteStorageTarget_S3::clear_access_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.access_key_.ClearToEmpty();
}
inline const std::string& RemoteStorageTarget_S3::access_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.S3.access_key)
  return _internal_access_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoteStorageTarget_S3::set_access_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.access_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.S3.access_key)
}
inline std::string* RemoteStorageTarget_S3::mutable_access_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_access_key();
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.S3.access_key)
  return _s;
}
inline const std::string& RemoteStorageTarget_S3::_internal_access_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.access_key_.Get();
}
inline void RemoteStorageTarget_S3::_internal_set_access_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.access_key_.Set(value, GetArena());
}
inline std::string* RemoteStorageTarget_S3::_internal_mutable_access_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.access_key_.Mutable( GetArena());
}
inline std::string* RemoteStorageTarget_S3::release_access_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.S3.access_key)
  return _impl_.access_key_.Release();
}
inline void RemoteStorageTarget_S3::set_allocated_access_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.access_key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.access_key_.IsDefault()) {
    _impl_.access_key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.S3.access_key)
}

// string secret_key = 6;
inline void RemoteStorageTarget_S3::clear_secret_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_key_.ClearToEmpty();
}
inline const std::string& RemoteStorageTarget_S3::secret_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.S3.secret_key)
  return _internal_secret_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoteStorageTarget_S3::set_secret_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.S3.secret_key)
}
inline std::string* RemoteStorageTarget_S3::mutable_secret_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_secret_key();
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.S3.secret_key)
  return _s;
}
inline const std::string& RemoteStorageTarget_S3::_internal_secret_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.secret_key_.Get();
}
inline void RemoteStorageTarget_S3::_internal_set_secret_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_key_.Set(value, GetArena());
}
inline std::string* RemoteStorageTarget_S3::_internal_mutable_secret_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.secret_key_.Mutable( GetArena());
}
inline std::string* RemoteStorageTarget_S3::release_secret_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.S3.secret_key)
  return _impl_.secret_key_.Release();
}
inline void RemoteStorageTarget_S3::set_allocated_secret_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.secret_key_.IsDefault()) {
    _impl_.secret_key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.S3.secret_key)
}

// -------------------------------------------------------------------

// RemoteStorageTarget_Azure

// .flex.RemoteStorageTarget.S3 s3 = 1;
inline bool RemoteStorageTarget_Azure::has_s3() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.s3_ != nullptr);
  return value;
}
inline void RemoteStorageTarget_Azure::clear_s3() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.s3_ != nullptr) _impl_.s3_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::flex::RemoteStorageTarget_S3& RemoteStorageTarget_Azure::_internal_s3() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::flex::RemoteStorageTarget_S3* p = _impl_.s3_;
  return p != nullptr ? *p : reinterpret_cast<const ::flex::RemoteStorageTarget_S3&>(::flex::_RemoteStorageTarget_S3_default_instance_);
}
inline const ::flex::RemoteStorageTarget_S3& RemoteStorageTarget_Azure::s3() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.Azure.s3)
  return _internal_s3();
}
inline void RemoteStorageTarget_Azure::unsafe_arena_set_allocated_s3(::flex::RemoteStorageTarget_S3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.s3_);
  }
  _impl_.s3_ = reinterpret_cast<::flex::RemoteStorageTarget_S3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.RemoteStorageTarget.Azure.s3)
}
inline ::flex::RemoteStorageTarget_S3* RemoteStorageTarget_Azure::release_s3() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::flex::RemoteStorageTarget_S3* released = _impl_.s3_;
  _impl_.s3_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::flex::RemoteStorageTarget_S3* RemoteStorageTarget_Azure::unsafe_arena_release_s3() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.Azure.s3)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::flex::RemoteStorageTarget_S3* temp = _impl_.s3_;
  _impl_.s3_ = nullptr;
  return temp;
}
inline ::flex::RemoteStorageTarget_S3* RemoteStorageTarget_Azure::_internal_mutable_s3() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.s3_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::flex::RemoteStorageTarget_S3>(GetArena());
    _impl_.s3_ = reinterpret_cast<::flex::RemoteStorageTarget_S3*>(p);
  }
  return _impl_.s3_;
}
inline ::flex::RemoteStorageTarget_S3* RemoteStorageTarget_Azure::mutable_s3() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::flex::RemoteStorageTarget_S3* _msg = _internal_mutable_s3();
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.Azure.s3)
  return _msg;
}
inline void RemoteStorageTarget_Azure::set_allocated_s3(::flex::RemoteStorageTarget_S3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.s3_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.s3_ = reinterpret_cast<::flex::RemoteStorageTarget_S3*>(value);
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.Azure.s3)
}

// string account = 2;
inline void RemoteStorageTarget_Azure::clear_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.ClearToEmpty();
}
inline const std::string& RemoteStorageTarget_Azure::account() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.Azure.account)
  return _internal_account();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoteStorageTarget_Azure::set_account(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.Azure.account)
}
inline std::string* RemoteStorageTarget_Azure::mutable_account() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.Azure.account)
  return _s;
}
inline const std::string& RemoteStorageTarget_Azure::_internal_account() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_.Get();
}
inline void RemoteStorageTarget_Azure::_internal_set_account(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.Set(value, GetArena());
}
inline std::string* RemoteStorageTarget_Azure::_internal_mutable_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.account_.Mutable( GetArena());
}
inline std::string* RemoteStorageTarget_Azure::release_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.Azure.account)
  return _impl_.account_.Release();
}
inline void RemoteStorageTarget_Azure::set_allocated_account(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.account_.IsDefault()) {
    _impl_.account_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.Azure.account)
}

// -------------------------------------------------------------------

// RemoteStorageTarget_POSIX

// string path = 1;
inline void RemoteStorageTarget_POSIX::clear_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.ClearToEmpty();
}
inline const std::string& RemoteStorageTarget_POSIX::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.POSIX.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoteStorageTarget_POSIX::set_path(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.POSIX.path)
}
inline std::string* RemoteStorageTarget_POSIX::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.POSIX.path)
  return _s;
}
inline const std::string& RemoteStorageTarget_POSIX::_internal_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.path_.Get();
}
inline void RemoteStorageTarget_POSIX::_internal_set_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.Set(value, GetArena());
}
inline std::string* RemoteStorageTarget_POSIX::_internal_mutable_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* RemoteStorageTarget_POSIX::release_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.POSIX.path)
  return _impl_.path_.Release();
}
inline void RemoteStorageTarget_POSIX::set_allocated_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.POSIX.path)
}

// -------------------------------------------------------------------

// RemoteStorageTarget

// uint32 id = 1;
inline void RemoteStorageTarget::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
}
inline ::uint32_t RemoteStorageTarget::id() const {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.id)
  return _internal_id();
}
inline void RemoteStorageTarget::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.id)
}
inline ::uint32_t RemoteStorageTarget::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void RemoteStorageTarget::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// string name = 2;
inline void RemoteStorageTarget::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RemoteStorageTarget::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoteStorageTarget::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.name)
}
inline std::string* RemoteStorageTarget::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.name)
  return _s;
}
inline const std::string& RemoteStorageTarget::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void RemoteStorageTarget::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* RemoteStorageTarget::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* RemoteStorageTarget::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.name)
  return _impl_.name_.Release();
}
inline void RemoteStorageTarget::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.name)
}

// .flex.RemoteStorageTarget.Policies policies = 3;
inline bool RemoteStorageTarget::has_policies() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.policies_ != nullptr);
  return value;
}
inline void RemoteStorageTarget::clear_policies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.policies_ != nullptr) _impl_.policies_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::flex::RemoteStorageTarget_Policies& RemoteStorageTarget::_internal_policies() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::flex::RemoteStorageTarget_Policies* p = _impl_.policies_;
  return p != nullptr ? *p : reinterpret_cast<const ::flex::RemoteStorageTarget_Policies&>(::flex::_RemoteStorageTarget_Policies_default_instance_);
}
inline const ::flex::RemoteStorageTarget_Policies& RemoteStorageTarget::policies() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.policies)
  return _internal_policies();
}
inline void RemoteStorageTarget::unsafe_arena_set_allocated_policies(::flex::RemoteStorageTarget_Policies* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.policies_);
  }
  _impl_.policies_ = reinterpret_cast<::flex::RemoteStorageTarget_Policies*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.RemoteStorageTarget.policies)
}
inline ::flex::RemoteStorageTarget_Policies* RemoteStorageTarget::release_policies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::flex::RemoteStorageTarget_Policies* released = _impl_.policies_;
  _impl_.policies_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::flex::RemoteStorageTarget_Policies* RemoteStorageTarget::unsafe_arena_release_policies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.policies)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::flex::RemoteStorageTarget_Policies* temp = _impl_.policies_;
  _impl_.policies_ = nullptr;
  return temp;
}
inline ::flex::RemoteStorageTarget_Policies* RemoteStorageTarget::_internal_mutable_policies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.policies_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::flex::RemoteStorageTarget_Policies>(GetArena());
    _impl_.policies_ = reinterpret_cast<::flex::RemoteStorageTarget_Policies*>(p);
  }
  return _impl_.policies_;
}
inline ::flex::RemoteStorageTarget_Policies* RemoteStorageTarget::mutable_policies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::flex::RemoteStorageTarget_Policies* _msg = _internal_mutable_policies();
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.policies)
  return _msg;
}
inline void RemoteStorageTarget::set_allocated_policies(::flex::RemoteStorageTarget_Policies* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.policies_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.policies_ = reinterpret_cast<::flex::RemoteStorageTarget_Policies*>(value);
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.policies)
}

// .flex.RemoteStorageTarget.S3 s3 = 4;
inline bool RemoteStorageTarget::has_s3() const {
  return type_case() == kS3;
}
inline bool RemoteStorageTarget::_internal_has_s3() const {
  return type_case() == kS3;
}
inline void RemoteStorageTarget::set_has_s3() {
  _impl_._oneof_case_[0] = kS3;
}
inline void RemoteStorageTarget::clear_s3() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kS3) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.s3_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.s3_);
    }
    clear_has_type();
  }
}
inline ::flex::RemoteStorageTarget_S3* RemoteStorageTarget::release_s3() {
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.s3)
  if (type_case() == kS3) {
    clear_has_type();
    auto* temp = _impl_.type_.s3_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flex::RemoteStorageTarget_S3& RemoteStorageTarget::_internal_s3() const {
  return type_case() == kS3 ? *_impl_.type_.s3_ : reinterpret_cast<::flex::RemoteStorageTarget_S3&>(::flex::_RemoteStorageTarget_S3_default_instance_);
}
inline const ::flex::RemoteStorageTarget_S3& RemoteStorageTarget::s3() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.s3)
  return _internal_s3();
}
inline ::flex::RemoteStorageTarget_S3* RemoteStorageTarget::unsafe_arena_release_s3() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.RemoteStorageTarget.s3)
  if (type_case() == kS3) {
    clear_has_type();
    auto* temp = _impl_.type_.s3_;
    _impl_.type_.s3_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RemoteStorageTarget::unsafe_arena_set_allocated_s3(::flex::RemoteStorageTarget_S3* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_s3();
    _impl_.type_.s3_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.RemoteStorageTarget.s3)
}
inline ::flex::RemoteStorageTarget_S3* RemoteStorageTarget::_internal_mutable_s3() {
  if (type_case() != kS3) {
    clear_type();
    set_has_s3();
    _impl_.type_.s3_ =
        ::google::protobuf::Message::DefaultConstruct<::flex::RemoteStorageTarget_S3>(GetArena());
  }
  return _impl_.type_.s3_;
}
inline ::flex::RemoteStorageTarget_S3* RemoteStorageTarget::mutable_s3() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::flex::RemoteStorageTarget_S3* _msg = _internal_mutable_s3();
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.s3)
  return _msg;
}

// .flex.RemoteStorageTarget.POSIX posix = 5;
inline bool RemoteStorageTarget::has_posix() const {
  return type_case() == kPosix;
}
inline bool RemoteStorageTarget::_internal_has_posix() const {
  return type_case() == kPosix;
}
inline void RemoteStorageTarget::set_has_posix() {
  _impl_._oneof_case_[0] = kPosix;
}
inline void RemoteStorageTarget::clear_posix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kPosix) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.posix_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.posix_);
    }
    clear_has_type();
  }
}
inline ::flex::RemoteStorageTarget_POSIX* RemoteStorageTarget::release_posix() {
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.posix)
  if (type_case() == kPosix) {
    clear_has_type();
    auto* temp = _impl_.type_.posix_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.posix_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flex::RemoteStorageTarget_POSIX& RemoteStorageTarget::_internal_posix() const {
  return type_case() == kPosix ? *_impl_.type_.posix_ : reinterpret_cast<::flex::RemoteStorageTarget_POSIX&>(::flex::_RemoteStorageTarget_POSIX_default_instance_);
}
inline const ::flex::RemoteStorageTarget_POSIX& RemoteStorageTarget::posix() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.posix)
  return _internal_posix();
}
inline ::flex::RemoteStorageTarget_POSIX* RemoteStorageTarget::unsafe_arena_release_posix() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.RemoteStorageTarget.posix)
  if (type_case() == kPosix) {
    clear_has_type();
    auto* temp = _impl_.type_.posix_;
    _impl_.type_.posix_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RemoteStorageTarget::unsafe_arena_set_allocated_posix(::flex::RemoteStorageTarget_POSIX* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_posix();
    _impl_.type_.posix_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.RemoteStorageTarget.posix)
}
inline ::flex::RemoteStorageTarget_POSIX* RemoteStorageTarget::_internal_mutable_posix() {
  if (type_case() != kPosix) {
    clear_type();
    set_has_posix();
    _impl_.type_.posix_ =
        ::google::protobuf::Message::DefaultConstruct<::flex::RemoteStorageTarget_POSIX>(GetArena());
  }
  return _impl_.type_.posix_;
}
inline ::flex::RemoteStorageTarget_POSIX* RemoteStorageTarget::mutable_posix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::flex::RemoteStorageTarget_POSIX* _msg = _internal_mutable_posix();
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.posix)
  return _msg;
}

// .flex.RemoteStorageTarget.Azure azure = 6;
inline bool RemoteStorageTarget::has_azure() const {
  return type_case() == kAzure;
}
inline bool RemoteStorageTarget::_internal_has_azure() const {
  return type_case() == kAzure;
}
inline void RemoteStorageTarget::set_has_azure() {
  _impl_._oneof_case_[0] = kAzure;
}
inline void RemoteStorageTarget::clear_azure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kAzure) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.azure_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.azure_);
    }
    clear_has_type();
  }
}
inline ::flex::RemoteStorageTarget_Azure* RemoteStorageTarget::release_azure() {
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.azure)
  if (type_case() == kAzure) {
    clear_has_type();
    auto* temp = _impl_.type_.azure_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flex::RemoteStorageTarget_Azure& RemoteStorageTarget::_internal_azure() const {
  return type_case() == kAzure ? *_impl_.type_.azure_ : reinterpret_cast<::flex::RemoteStorageTarget_Azure&>(::flex::_RemoteStorageTarget_Azure_default_instance_);
}
inline const ::flex::RemoteStorageTarget_Azure& RemoteStorageTarget::azure() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.azure)
  return _internal_azure();
}
inline ::flex::RemoteStorageTarget_Azure* RemoteStorageTarget::unsafe_arena_release_azure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:flex.RemoteStorageTarget.azure)
  if (type_case() == kAzure) {
    clear_has_type();
    auto* temp = _impl_.type_.azure_;
    _impl_.type_.azure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RemoteStorageTarget::unsafe_arena_set_allocated_azure(::flex::RemoteStorageTarget_Azure* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_azure();
    _impl_.type_.azure_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flex.RemoteStorageTarget.azure)
}
inline ::flex::RemoteStorageTarget_Azure* RemoteStorageTarget::_internal_mutable_azure() {
  if (type_case() != kAzure) {
    clear_type();
    set_has_azure();
    _impl_.type_.azure_ =
        ::google::protobuf::Message::DefaultConstruct<::flex::RemoteStorageTarget_Azure>(GetArena());
  }
  return _impl_.type_.azure_;
}
inline ::flex::RemoteStorageTarget_Azure* RemoteStorageTarget::mutable_azure() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::flex::RemoteStorageTarget_Azure* _msg = _internal_mutable_azure();
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.azure)
  return _msg;
}

// string mock = 7;
inline bool RemoteStorageTarget::has_mock() const {
  return type_case() == kMock;
}
inline void RemoteStorageTarget::set_has_mock() {
  _impl_._oneof_case_[0] = kMock;
}
inline void RemoteStorageTarget::clear_mock() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() == kMock) {
    _impl_.type_.mock_.Destroy();
    clear_has_type();
  }
}
inline const std::string& RemoteStorageTarget::mock() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:flex.RemoteStorageTarget.mock)
  return _internal_mock();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoteStorageTarget::set_mock(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() != kMock) {
    clear_type();

    set_has_mock();
    _impl_.type_.mock_.InitDefault();
  }
  _impl_.type_.mock_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:flex.RemoteStorageTarget.mock)
}
inline std::string* RemoteStorageTarget::mutable_mock() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mock();
  // @@protoc_insertion_point(field_mutable:flex.RemoteStorageTarget.mock)
  return _s;
}
inline const std::string& RemoteStorageTarget::_internal_mock() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (type_case() != kMock) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.type_.mock_.Get();
}
inline void RemoteStorageTarget::_internal_set_mock(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() != kMock) {
    clear_type();

    set_has_mock();
    _impl_.type_.mock_.InitDefault();
  }
  _impl_.type_.mock_.Set(value, GetArena());
}
inline std::string* RemoteStorageTarget::_internal_mutable_mock() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (type_case() != kMock) {
    clear_type();

    set_has_mock();
    _impl_.type_.mock_.InitDefault();
  }
  return _impl_.type_.mock_.Mutable( GetArena());
}
inline std::string* RemoteStorageTarget::release_mock() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:flex.RemoteStorageTarget.mock)
  if (type_case() != kMock) {
    return nullptr;
  }
  clear_has_type();
  return _impl_.type_.mock_.Release();
}
inline void RemoteStorageTarget::set_allocated_mock(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_type()) {
    clear_type();
  }
  if (value != nullptr) {
    set_has_mock();
    _impl_.type_.mock_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:flex.RemoteStorageTarget.mock)
}

inline bool RemoteStorageTarget::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void RemoteStorageTarget::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline RemoteStorageTarget::TypeCase RemoteStorageTarget::type_case() const {
  return RemoteStorageTarget::TypeCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace flex


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::flex::UpdateWorkRequest_NewState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::flex::UpdateWorkRequest_NewState>() {
  return ::flex::UpdateWorkRequest_NewState_descriptor();
}
template <>
struct is_proto_enum<::flex::BulkUpdateWorkRequest_NewState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::flex::BulkUpdateWorkRequest_NewState>() {
  return ::flex::BulkUpdateWorkRequest_NewState_descriptor();
}
template <>
struct is_proto_enum<::flex::SyncJob_Operation> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::flex::SyncJob_Operation>() {
  return ::flex::SyncJob_Operation_descriptor();
}
template <>
struct is_proto_enum<::flex::Work_State> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::flex::Work_State>() {
  return ::flex::Work_State_descriptor();
}
template <>
struct is_proto_enum<::flex::UpdateConfigResponse_Result> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::flex::UpdateConfigResponse_Result>() {
  return ::flex::UpdateConfigResponse_Result_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // flex_2eproto_2epb_2eh
