// This file is @generated by prost-build.
/// The "legacy" BeeGFS numeric Id-NodeType combination that can be used to identify an entity like
/// a node or target. Because each entity type has its own id space (meaning a combination is not
/// globally unique), the entity type must be known in addition to uniquely identify an entity.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LegacyId {
    /// BeeGFS numeric id.
    /// Required, 0 is invalid.
    #[prost(uint32, tag = "1")]
    pub num_id: u32,
    /// BeeGFS node type.
    /// Required. Despite the name, also applies to other entity types (which can only be on a node of
    /// their own type, so it's still correct).
    #[prost(enumeration = "NodeType", tag = "2")]
    pub node_type: i32,
}
/// Contains all identifiers used to uniquely identify an entity like a node or a target. Mainly
/// meant for communication with management as management has access to all the information. This
/// message should be used in two ways:
/// 1) In a request message (to the management),  only _one_ of the fields needs to be set (each is
/// enough to identify an entity (legacy_id with extra knowledge).
/// 2) In a response message (from the management), _all_ fields should be set. The request processor
/// should have all info about an entity available. If that isn't the case, leaving fields empty is
/// allowed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityIdSet {
    /// The global, unique entity id. Identifies an entity from all types without any additional
    /// context.
    /// Optional or Required, depending on the use case. 0 is invalid.
    #[prost(int64, optional, tag = "1")]
    pub uid: ::core::option::Option<i64>,
    /// The user definable globally unique alias of an entity. Identifies an entity from all types
    /// without any additional context.
    /// Optional or Required, depending on the use case. Aliases must start with letter and contain
    /// only \[a-zA-Z0-9_-.\].
    #[prost(string, optional, tag = "2")]
    pub alias: ::core::option::Option<::prost::alloc::string::String>,
    /// The "legacy" style numeric Id-NodeType combination. The entity type must be known in addition
    /// to uniquely identify an entity with this field.
    /// Optional or Required, depending on the use case.
    #[prost(message, optional, tag = "3")]
    pub legacy_id: ::core::option::Option<LegacyId>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EntityType {
    Unspecified = 0,
    Node = 1,
    Target = 2,
    BuddyGroup = 3,
    Pool = 4,
}
impl EntityType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ENTITY_TYPE_UNSPECIFIED",
            Self::Node => "NODE",
            Self::Target => "TARGET",
            Self::BuddyGroup => "BUDDY_GROUP",
            Self::Pool => "POOL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENTITY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "NODE" => Some(Self::Node),
            "TARGET" => Some(Self::Target),
            "BUDDY_GROUP" => Some(Self::BuddyGroup),
            "POOL" => Some(Self::Pool),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodeType {
    Unspecified = 0,
    Client = 1,
    Meta = 2,
    Storage = 3,
    Management = 4,
}
impl NodeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NODE_TYPE_UNSPECIFIED",
            Self::Client => "CLIENT",
            Self::Meta => "META",
            Self::Storage => "STORAGE",
            Self::Management => "MANAGEMENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NODE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CLIENT" => Some(Self::Client),
            "META" => Some(Self::Meta),
            "STORAGE" => Some(Self::Storage),
            "MANAGEMENT" => Some(Self::Management),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReachabilityState {
    Unspecified = 0,
    Online = 1,
    Poffline = 2,
    Offline = 3,
}
impl ReachabilityState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "REACHABILITY_STATE_UNSPECIFIED",
            Self::Online => "ONLINE",
            Self::Poffline => "POFFLINE",
            Self::Offline => "OFFLINE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REACHABILITY_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "ONLINE" => Some(Self::Online),
            "POFFLINE" => Some(Self::Poffline),
            "OFFLINE" => Some(Self::Offline),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConsistencyState {
    Unspecified = 0,
    Good = 1,
    NeedsResync = 2,
    Bad = 3,
}
impl ConsistencyState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CONSISTENCY_STATE_UNSPECIFIED",
            Self::Good => "GOOD",
            Self::NeedsResync => "NEEDS_RESYNC",
            Self::Bad => "BAD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONSISTENCY_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "GOOD" => Some(Self::Good),
            "NEEDS_RESYNC" => Some(Self::NeedsResync),
            "BAD" => Some(Self::Bad),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CapacityPool {
    Unspecified = 0,
    Normal = 1,
    Low = 2,
    Emergency = 3,
}
impl CapacityPool {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CAPACITY_POOL_UNSPECIFIED",
            Self::Normal => "NORMAL",
            Self::Low => "LOW",
            Self::Emergency => "EMERGENCY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CAPACITY_POOL_UNSPECIFIED" => Some(Self::Unspecified),
            "NORMAL" => Some(Self::Normal),
            "LOW" => Some(Self::Low),
            "EMERGENCY" => Some(Self::Emergency),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NicType {
    Unspecified = 0,
    Ethernet = 1,
    Rdma = 2,
}
impl NicType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NIC_TYPE_UNSPECIFIED",
            Self::Ethernet => "ETHERNET",
            Self::Rdma => "RDMA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NIC_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ETHERNET" => Some(Self::Ethernet),
            "RDMA" => Some(Self::Rdma),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QuotaIdType {
    Unspecified = 0,
    User = 1,
    Group = 2,
}
impl QuotaIdType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "QUOTA_ID_TYPE_UNSPECIFIED",
            Self::User => "QUOTA_ID_TYPE_USER",
            Self::Group => "QUOTA_ID_TYPE_GROUP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "QUOTA_ID_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "QUOTA_ID_TYPE_USER" => Some(Self::User),
            "QUOTA_ID_TYPE_GROUP" => Some(Self::Group),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QuotaType {
    Unspecified = 0,
    Space = 1,
    Inode = 2,
}
impl QuotaType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "QUOTA_TYPE_UNSPECIFIED",
            Self::Space => "QUOTA_TYPE_SPACE",
            Self::Inode => "QUOTA_TYPE_INODE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "QUOTA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "QUOTA_TYPE_SPACE" => Some(Self::Space),
            "QUOTA_TYPE_INODE" => Some(Self::Inode),
            _ => None,
        }
    }
}
