// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitJobRequest {
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<JobRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitJobResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<JobResult>,
    #[prost(enumeration = "submit_job_response::ResponseStatus", tag = "2")]
    pub status: i32,
}
/// Nested message and enum types in `SubmitJobResponse`.
pub mod submit_job_response {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResponseStatus {
        Invalid = 0,
        Created = 1,
        Existing = 2,
        NotAllowed = 3,
        AlreadyComplete = 4,
        AlreadyOffloaded = 5,
    }
    impl ResponseStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ResponseStatus::Invalid => "INVALID",
                ResponseStatus::Created => "CREATED",
                ResponseStatus::Existing => "EXISTING",
                ResponseStatus::NotAllowed => "NOT_ALLOWED",
                ResponseStatus::AlreadyComplete => "ALREADY_COMPLETE",
                ResponseStatus::AlreadyOffloaded => "ALREADY_OFFLOADED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INVALID" => Some(Self::Invalid),
                "CREATED" => Some(Self::Created),
                "EXISTING" => Some(Self::Existing),
                "NOT_ALLOWED" => Some(Self::NotAllowed),
                "ALREADY_COMPLETE" => Some(Self::AlreadyComplete),
                "ALREADY_OFFLOADED" => Some(Self::AlreadyOffloaded),
                _ => None,
            }
        }
    }
}
/// A JobRequest contains all the information necessary for BeeRemote to trigger
/// a job on the appropriate worker node(s) (like BeeSync nodes) based on the
/// particular request_type specified by the user. It is the external request
/// so it does not include automatically generated fields like the job ID or
/// anything about the work request(s) used to execute the job.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobRequest {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// An arbitrary name for a job can be specified.
    /// Job names are optional and not need to be unique.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub priority: i32,
    /// This is the uint32 ID, NOT an actual reference to an RST.
    /// This ensures we don't have to include the full RST configuration,
    /// every time we send a Entry (commonly as part of a Job).
    #[prost(uint32, tag = "4")]
    pub remote_storage_target: u32,
    /// When force is set this request will create a new job even if there is already a completed
    /// job. When forced the request will return an error if there is already a job running. This is
    /// part of the JobRequest instead of the SubmitJobRequest message in case it ever is important
    /// to know if a particular job request was forced.
    #[prost(bool, tag = "5")]
    pub force: bool,
    /// When stub_local is set the local file with be a stub file
    #[prost(bool, tag = "7")]
    pub stub_local: bool,
    #[prost(oneof = "job_request::Type", tags = "10, 11, 12")]
    pub r#type: ::core::option::Option<job_request::Type>,
}
/// Nested message and enum types in `JobRequest`.
pub mod job_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "10")]
        Sync(super::super::flex::SyncJob),
        #[prost(message, tag = "11")]
        Mock(super::super::flex::MockJob),
        #[prost(message, tag = "12")]
        Builder(super::super::flex::BuilderJob),
    }
}
/// Job contains all the data from the original request plus the job ID and
/// current status. This is what is stored in the database for each path. We
/// don't embed results of a job in the Job because we store the Job and its
/// WorkResults (the latest work response from each worker node) in separate
/// key/value stores. This approach simplifies encoding and decoding these
/// messages and allows us to quickly look up jobs by path or ID.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Job {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub request: ::core::option::Option<JobRequest>,
    #[prost(message, optional, tag = "3")]
    pub created: ::core::option::Option<::prost_types::Timestamp>,
    /// Status is usually updated using `GetStatus()` which returns a status a pointer to the status
    /// of the overall job. Because it returns a pointer the status and/or message can be updated
    /// directly. This allows you to modify one but not the other field (commonly message can change
    /// but status should not). The state should encompass the results for individual work requests.
    /// For example if some WRs are finished and others are still running the state would be RUNNING.
    #[prost(message, optional, tag = "4")]
    pub status: ::core::option::Option<job::Status>,
    /// Used as the upload ID for multipart uploads, or any other time
    /// an external identifer is needed to coordinate a distributed transfer.
    #[prost(string, tag = "5")]
    pub external_id: ::prost::alloc::string::String,
    /// start_mtime is the modification timestamp from a stat of the local file in BeeGFS captured
    /// just before the job is started and any work requests are scheduled. This may be nil if there
    /// is no file in BeeGFS at the start of the job. A caller might wish to compare the start/stop
    /// mtime to determine if a file changed while being synchronized.
    #[prost(message, optional, tag = "6")]
    pub start_mtime: ::core::option::Option<::prost_types::Timestamp>,
    /// stop_mtime is the modification timestamp from a stat of the local file in BeeGFS captured
    /// just before the job is completed but after all work requests have finished executing. The
    /// stop_mtime is always set regardless if the job completes successfully, was aborted, or there
    /// was an error completing the job. Consumers should not blindly rely on stop_mtime to determine
    /// the state of a file, and should also check the job state. For example to determine if a file
    /// in BeeGFS based on its current mtime matches the mtime of a successfully uploaded file. This
    /// may be nil if there is no file in BeeGFS at the end of the job.
    #[prost(message, optional, tag = "7")]
    pub stop_mtime: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Job`.
pub mod job {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Status {
        #[prost(enumeration = "State", tag = "1")]
        pub state: i32,
        /// Message should be used to return any additional details, particularly to aid in
        /// troubleshooting. When useful for troubleshooting, multiple historical messages may be
        /// concatenated together in the format: "oldest message; newer message; newest message".
        /// Especially if the request goes through multiple state transitions (for example error to
        /// failed) this can be helpful to troubleshoot the chain of events that lead to a failure.
        /// Note messages should not be concatenated for the entire life of a request, and should
        /// generally be reset when either the state transitions from an expected to another expected
        /// state (i.e., UNASSIGNED->SCHEDULED), or when a request experienced an error or failure and
        /// was automatically or manually retried. Don't keep the message intact across multiple failed
        /// retries as this (a) makes troubleshooting each failure difficult and (b) means the message
        /// size can eventually grow beyond a reasonable limit and cause other issues.
        #[prost(string, tag = "2")]
        pub message: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub updated: ::core::option::Option<::prost_types::Timestamp>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// This state has no semantic value and the state should never be UNSPECIFIED unless there
        /// is a bug.
        Unspecified = 0,
        /// Used when the state of a job cannot be definitively determined. For example if a work
        /// request is in an unknown state, or if all WRs are either in a terminal state or require
        /// user intervention, but they are not all in the same state.
        Unknown = 1,
        /// Initially all jobs start out in the UNASSIGNED state. This indicates BeeRemote has not
        /// had a chance to schedule work requests for the job to any worker node(s).
        Unassigned = 2,
        /// When all worker node(s) have accepted the job's work requests, but may be waiting on
        /// an available worker goroutine to pickup the request.
        Scheduled = 3,
        /// When all work requests for this job are in progress.
        Running = 4,
        /// TODO: <https://github.com/ThinkParQ/bee-remote/issues/16>
        /// A user manually requested the job be paused.
        /// PAUSED = 5;
        ///
        /// ERROR indicates one or more transient/ephemeral error(s) occurred carrying out the job,
        /// but the worker nodes are still retrying the requests. Once the allowed number of retries
        /// or retry timeout is exceed, the work requests will fail, and the overall job state will
        /// be failed. In this state work requests are still active on the worker nodes, and jobs in
        /// the error state must be cancelled or complete successfully before new jobs are allowed
        /// for this RST+path combo.
        Error = 6,
        /// FAILED indicates one or more unrecoverable errors occurred carrying out this job.
        /// Typically jobs fail due to some condition that requires user intervention, such as
        /// updating the RST configuration, but can also fail if work requests exceed the allowed
        /// number of retries or retry timeout. Failed indicates no work requests for this job are
        /// scheduled to the worker nodes (meaning it can be cancelled without talking to the
        /// workers), however any associated external IDs (such as a multipart upload) have not been
        /// invalidated, because (1) if we're able to resume the job later this avoids having to
        /// reupload/download data and (2) it is unlikely the RST is in a state we can interact with
        /// it anyway. As a result jobs in the failed state must be cancelled before new jobs are
        /// allowed for this RST+path combo.
        ///
        /// TODO: <https://github.com/ThinkParQ/bee-remote/issues/27.>
        /// Update the ERROR and FAILED state descriptions based on the decisions made around
        /// allowing jobs to be resumed after an error/failure occurs.
        Failed = 7,
        /// Jobs and their WRs may be cancelled manually be a user. This is a terminal state and no
        /// further changes are possible once a job enters this state.
        Cancelled = 8,
        /// If the job and its WRs completed successfully. This is a terminal state and no further
        /// state changes are possible once a job enters this state.
        Completed = 9,
        /// If the job's WRs completed successfully and a stub has replaced the local file. This is a
        /// terminal state and no further state changes are possible once a job enters this state.
        Offloaded = 10,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "UNSPECIFIED",
                State::Unknown => "UNKNOWN",
                State::Unassigned => "UNASSIGNED",
                State::Scheduled => "SCHEDULED",
                State::Running => "RUNNING",
                State::Error => "ERROR",
                State::Failed => "FAILED",
                State::Cancelled => "CANCELLED",
                State::Completed => "COMPLETED",
                State::Offloaded => "OFFLOADED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNASSIGNED" => Some(Self::Unassigned),
                "SCHEDULED" => Some(Self::Scheduled),
                "RUNNING" => Some(Self::Running),
                "ERROR" => Some(Self::Error),
                "FAILED" => Some(Self::Failed),
                "CANCELLED" => Some(Self::Cancelled),
                "COMPLETED" => Some(Self::Completed),
                "OFFLOADED" => Some(Self::Offloaded),
                _ => None,
            }
        }
    }
}
/// The JobResult is used to return information about a job and its work results. Note the work
/// results are not directly embedded in the Job message to reduce the amount of data that needs to
/// be stored on-disk (notably work requests are deterministically generated).
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JobResult {
    #[prost(message, optional, tag = "1")]
    pub job: ::core::option::Option<Job>,
    #[prost(message, repeated, tag = "2")]
    pub work_requests: ::prost::alloc::vec::Vec<super::flex::WorkRequest>,
    #[prost(message, repeated, tag = "3")]
    pub work_results: ::prost::alloc::vec::Vec<job_result::WorkResult>,
}
/// Nested message and enum types in `JobResult`.
pub mod job_result {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WorkResult {
        #[prost(message, optional, tag = "1")]
        pub work: ::core::option::Option<super::super::flex::Work>,
        #[prost(string, tag = "2")]
        pub assigned_node: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub assigned_pool: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePathsRequest {
    #[prost(string, tag = "1")]
    pub path_prefix: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub requested_update: ::core::option::Option<UpdateJobsRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePathsResponse {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub update_result: ::core::option::Option<UpdateJobsResponse>,
}
/// UpdateJobsRequest is used to update one or more jobs for a particular path.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateJobsRequest {
    /// The path with the job(s) to update. Ignored when updating multiple paths via
    /// UpdatePathsRequest.
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// Optional: Only update a single job for the specified path. If this job ID is not found for
    /// the specified path, the response will be !ok.
    #[prost(string, optional, tag = "2")]
    pub job_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional: Only update job(s) for the specified remote targets. When also filtering by job ID,
    /// if the specified ID is not for any of these remote targets, the response will be !ok.
    #[prost(map = "uint32, bool", tag = "3")]
    pub remote_targets: ::std::collections::HashMap<u32, bool>,
    /// Required: The new state to set the job(s) to.
    #[prost(enumeration = "update_jobs_request::NewState", tag = "10")]
    pub new_state: i32,
    /// Optional: Normally completed jobs are ignored when making updates so some number of completed
    /// jobs can be automatically retained to determine when a path has been successfully
    /// synchronized with an RST. If a user wants to delete a completed job, or perhaps there was
    /// some bug and the user wants to go back through the steps to cancel a job to try and
    /// cleanup/recover, this can be done through a force update.
    #[prost(bool, tag = "4")]
    pub force_update: bool,
}
/// Nested message and enum types in `UpdateJobsRequest`.
pub mod update_jobs_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NewState {
        Unspecified = 0,
        Cancelled = 1,
        Deleted = 2,
    }
    impl NewState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NewState::Unspecified => "UNSPECIFIED",
                NewState::Cancelled => "CANCELLED",
                NewState::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "CANCELLED" => Some(Self::Cancelled),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
}
/// UpdateJobsResponse returns the result of updating one or more job(s) for a particular path.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateJobsResponse {
    /// Required: If the newState could not be applied to any of the jobs then ok will be false.
    /// Inspect the message and individual job responses to troubleshoot further.
    #[prost(bool, tag = "1")]
    pub ok: bool,
    /// Required: Generally the message will indicate any overall errors applying the update whereas
    /// the status of individual jobs will indicate problems applying updates to a particular job.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub results: ::prost::alloc::vec::Vec<JobResult>,
}
/// The number of query options is limited because we store jobs in a key/value
/// store where the key is essentially the equivalent of an index in a
/// traditional RDBMS. To optimize for multiple search terms we need to use
/// multiple k/v stores using a different item we want to query for as the key.
/// With the MapStore used as a wrapper around the BadgerDB k/v store we don't
/// have to duplicate all information and can use the Metadata field of the
/// MapStore to create references to data stored in other MapStores.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetJobsRequest {
    #[prost(bool, tag = "4")]
    pub include_work_requests: bool,
    /// Set to true to also return work results details.
    #[prost(bool, tag = "5")]
    pub include_work_results: bool,
    /// By default we just return the latest results known to BeeRemote and don't
    /// pull the latest work results from worker nodes and update the job status.
    /// We can optionally request an update from all worker nodes for each job
    /// and also update the job status, however this inccurs extra overhead as we'll
    /// have to lock the entries and send extra messages to get the latest status.
    /// Generally this should only be used to get the latest updates from a single
    /// job or all jobs for a particular path.
    #[prost(bool, tag = "6")]
    pub update_work_results: bool,
    #[prost(oneof = "get_jobs_request::Query", tags = "1, 2, 3")]
    pub query: ::core::option::Option<get_jobs_request::Query>,
}
/// Nested message and enum types in `GetJobsRequest`.
pub mod get_jobs_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct QueryIdAndPath {
        #[prost(string, tag = "1")]
        pub job_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub path: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Query {
        /// Returns at most one Job.
        #[prost(message, tag = "1")]
        ByJobIdAndPath(QueryIdAndPath),
        /// Returns all Jobs for the specified path.
        #[prost(string, tag = "2")]
        ByExactPath(::prost::alloc::string::String),
        /// Returns all Jobs for the specified paths.
        /// All jobs can be returned by specifying "/".
        #[prost(string, tag = "3")]
        ByPathPrefix(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetJobsResponse {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<JobResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkRequest {
    #[prost(message, optional, tag = "1")]
    pub work: ::core::option::Option<super::flex::Work>,
}
/// We use our own empty message instead of google.protobuf.Empty to ensure backwards
/// compatibility should we need to add fields in the future.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateWorkResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRstConfigRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRstConfigResponse {
    #[prost(message, repeated, tag = "1")]
    pub rsts: ::prost::alloc::vec::Vec<super::flex::RemoteStorageTarget>,
}
/// Generated client implementations.
pub mod bee_remote_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Externally facing RPCs and messages clients and worker nodes use to interact
    /// with BeeRemote.
    #[derive(Debug, Clone)]
    pub struct BeeRemoteClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BeeRemoteClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BeeRemoteClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BeeRemoteClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            BeeRemoteClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn submit_job(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitJobResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/beeremote.BeeRemote/SubmitJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("beeremote.BeeRemote", "SubmitJob"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_paths(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdatePathsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::UpdatePathsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/beeremote.BeeRemote/UpdatePaths",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("beeremote.BeeRemote", "UpdatePaths"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn update_jobs(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateJobsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateJobsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/beeremote.BeeRemote/UpdateJobs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("beeremote.BeeRemote", "UpdateJobs"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_jobs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetJobsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetJobsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/beeremote.BeeRemote/GetJobs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("beeremote.BeeRemote", "GetJobs"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Rather then BeeRemote connecting to a worker node and using a streaming RPC to return work
        /// results, we have BeeRemote expose a unary RPC that is used to send results back as they are
        /// available. This allows us to avoid complex error handling needed to reliably use streams, and
        /// more easily adhere to our requirement that work requests are always owned by BeeRemote or its
        /// worker nodes and no polling is needed to check on the state of the requests. With this
        /// approach either side can make an unary request for a particular work request, and look at the
        /// response to verify ownership has successfully move to the other node (i.e., the node has
        /// committed the request to its on-disk database). IMPORTANT: This is only intended to be called
        /// by worker nodes.
        pub async fn update_work(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateWorkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateWorkResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/beeremote.BeeRemote/UpdateWork",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("beeremote.BeeRemote", "UpdateWork"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_rst_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRstConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetRstConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/beeremote.BeeRemote/GetRSTConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("beeremote.BeeRemote", "GetRSTConfig"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod bee_remote_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with BeeRemoteServer.
    #[async_trait]
    pub trait BeeRemote: Send + Sync + 'static {
        async fn submit_job(
            &self,
            request: tonic::Request<super::SubmitJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitJobResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the UpdatePaths method.
        type UpdatePathsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::UpdatePathsResponse, tonic::Status>,
            >
            + Send
            + 'static;
        async fn update_paths(
            &self,
            request: tonic::Request<super::UpdatePathsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::UpdatePathsStream>,
            tonic::Status,
        >;
        async fn update_jobs(
            &self,
            request: tonic::Request<super::UpdateJobsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateJobsResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetJobs method.
        type GetJobsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::GetJobsResponse, tonic::Status>,
            >
            + Send
            + 'static;
        async fn get_jobs(
            &self,
            request: tonic::Request<super::GetJobsRequest>,
        ) -> std::result::Result<tonic::Response<Self::GetJobsStream>, tonic::Status>;
        /// Rather then BeeRemote connecting to a worker node and using a streaming RPC to return work
        /// results, we have BeeRemote expose a unary RPC that is used to send results back as they are
        /// available. This allows us to avoid complex error handling needed to reliably use streams, and
        /// more easily adhere to our requirement that work requests are always owned by BeeRemote or its
        /// worker nodes and no polling is needed to check on the state of the requests. With this
        /// approach either side can make an unary request for a particular work request, and look at the
        /// response to verify ownership has successfully move to the other node (i.e., the node has
        /// committed the request to its on-disk database). IMPORTANT: This is only intended to be called
        /// by worker nodes.
        async fn update_work(
            &self,
            request: tonic::Request<super::UpdateWorkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateWorkResponse>,
            tonic::Status,
        >;
        async fn get_rst_config(
            &self,
            request: tonic::Request<super::GetRstConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetRstConfigResponse>,
            tonic::Status,
        >;
    }
    /// Externally facing RPCs and messages clients and worker nodes use to interact
    /// with BeeRemote.
    #[derive(Debug)]
    pub struct BeeRemoteServer<T: BeeRemote> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: BeeRemote> BeeRemoteServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for BeeRemoteServer<T>
    where
        T: BeeRemote,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/beeremote.BeeRemote/SubmitJob" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitJobSvc<T: BeeRemote>(pub Arc<T>);
                    impl<
                        T: BeeRemote,
                    > tonic::server::UnaryService<super::SubmitJobRequest>
                    for SubmitJobSvc<T> {
                        type Response = super::SubmitJobResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubmitJobRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BeeRemote>::submit_job(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = SubmitJobSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/beeremote.BeeRemote/UpdatePaths" => {
                    #[allow(non_camel_case_types)]
                    struct UpdatePathsSvc<T: BeeRemote>(pub Arc<T>);
                    impl<
                        T: BeeRemote,
                    > tonic::server::ServerStreamingService<super::UpdatePathsRequest>
                    for UpdatePathsSvc<T> {
                        type Response = super::UpdatePathsResponse;
                        type ResponseStream = T::UpdatePathsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdatePathsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BeeRemote>::update_paths(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = UpdatePathsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/beeremote.BeeRemote/UpdateJobs" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateJobsSvc<T: BeeRemote>(pub Arc<T>);
                    impl<
                        T: BeeRemote,
                    > tonic::server::UnaryService<super::UpdateJobsRequest>
                    for UpdateJobsSvc<T> {
                        type Response = super::UpdateJobsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateJobsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BeeRemote>::update_jobs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = UpdateJobsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/beeremote.BeeRemote/GetJobs" => {
                    #[allow(non_camel_case_types)]
                    struct GetJobsSvc<T: BeeRemote>(pub Arc<T>);
                    impl<
                        T: BeeRemote,
                    > tonic::server::ServerStreamingService<super::GetJobsRequest>
                    for GetJobsSvc<T> {
                        type Response = super::GetJobsResponse;
                        type ResponseStream = T::GetJobsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetJobsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BeeRemote>::get_jobs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetJobsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/beeremote.BeeRemote/UpdateWork" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateWorkSvc<T: BeeRemote>(pub Arc<T>);
                    impl<
                        T: BeeRemote,
                    > tonic::server::UnaryService<super::UpdateWorkRequest>
                    for UpdateWorkSvc<T> {
                        type Response = super::UpdateWorkResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateWorkRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BeeRemote>::update_work(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = UpdateWorkSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/beeremote.BeeRemote/GetRSTConfig" => {
                    #[allow(non_camel_case_types)]
                    struct GetRSTConfigSvc<T: BeeRemote>(pub Arc<T>);
                    impl<
                        T: BeeRemote,
                    > tonic::server::UnaryService<super::GetRstConfigRequest>
                    for GetRSTConfigSvc<T> {
                        type Response = super::GetRstConfigResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetRstConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BeeRemote>::get_rst_config(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetRSTConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: BeeRemote> Clone for BeeRemoteServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: BeeRemote> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: BeeRemote> tonic::server::NamedService for BeeRemoteServer<T> {
        const NAME: &'static str = "beeremote.BeeRemote";
    }
}
