// This file is @generated by prost-build.
/// The result of a certificate verfication operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifyCertResult {
    #[prost(enumeration = "VerifyResult", tag = "1")]
    pub result: i32,
    /// The certificates string serial. Empty if verification failed.
    #[prost(string, tag = "2")]
    pub serial: ::prost::alloc::string::String,
    /// Error or status message. Empty if verification succeeded. Contains the error message if
    /// result == VERIFY_ERROR and the reason for verification failure if result == VERIFY_INVALID.
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
/// The result of a feature verification operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifyFeatureResult {
    #[prost(enumeration = "VerifyResult", tag = "1")]
    pub result: i32,
    /// Error or status message. Empty if verification succeeded. Contains the error message if
    /// result == VERIFY_ERROR and the reason for verification failure if result == VERIFY_INVALID.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// The result of an operation that fetches the data of the currently loaded certificate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCertDataResult {
    #[prost(enumeration = "VerifyResult", tag = "1")]
    pub result: i32,
    /// The data of the certificate currently loaded in the library. Data is present even if
    /// verification failed.
    #[prost(message, optional, tag = "2")]
    pub data: ::core::option::Option<CertData>,
    /// Error or status message. Empty if verification succeeded. Contains the error message if
    /// result == VERIFY_ERROR and the reason for verification failure if result == VERIFY_INVALID.
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
/// CertData is a simplified version of a Go x509.certificate that contains a subset of its
/// information and some additional information relevant to BeeGFS licenses like the certificate
/// type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CertData {
    /// Certificate type. Encoded in the subject SerialNumber and CommonName of the x509 certificate
    /// together with the account ID.
    #[prost(enumeration = "CertType", tag = "1")]
    pub r#type: i32,
    /// Random int64 x509 serial number that uniquely identifies the certificate
    #[prost(int64, tag = "2")]
    pub serial: i64,
    /// Fields 3-8 contain an x509 certificate subject's attributes
    #[prost(string, tag = "3")]
    pub organization: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub organizational_unit: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub country: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub locality: ::prost::alloc::string::String,
    /// String serial number that contains the type (P-, SP-, ...) and the partner account ID or
    /// support contract ID
    #[prost(string, tag = "7")]
    pub common_name: ::prost::alloc::string::String,
    /// Can contain a different string serial number (for example a customer ID). It doesn't carry any
    /// semantic meaning for now.
    #[prost(string, tag = "8")]
    pub subject_serial: ::prost::alloc::string::String,
    /// Fields 8 and 9 encode the certificate's validity period
    #[prost(message, optional, tag = "9")]
    pub valid_from: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub valid_until: ::core::option::Option<::prost_types::Timestamp>,
    /// The DNS names the certificate is valid for. BeeGFS license certificates encode licensed
    /// features as DNS names, e.g. "io.beegfs.mirroring" or "io.beegfs.numservers.4"
    #[prost(string, repeated, tag = "11")]
    pub dns_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Indicates whether the certificate is part of a CA. Always false for customer and partner
    /// certificates.
    #[prost(bool, tag = "12")]
    pub is_ca: bool,
    /// The certificate's parent or "Issuer" certificate
    #[prost(message, optional, boxed, tag = "13")]
    pub parent_data: ::core::option::Option<::prost::alloc::boxed::Box<CertData>>,
}
/// The three types of result a certificate verification can produce.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VerifyResult {
    VerifyUnspecified = 0,
    VerifyError = 1,
    VerifyValid = 2,
    VerifyInvalid = 3,
}
impl VerifyResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::VerifyUnspecified => "VERIFY_UNSPECIFIED",
            Self::VerifyError => "VERIFY_ERROR",
            Self::VerifyValid => "VERIFY_VALID",
            Self::VerifyInvalid => "VERIFY_INVALID",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VERIFY_UNSPECIFIED" => Some(Self::VerifyUnspecified),
            "VERIFY_ERROR" => Some(Self::VerifyError),
            "VERIFY_VALID" => Some(Self::VerifyValid),
            "VERIFY_INVALID" => Some(Self::VerifyInvalid),
            _ => None,
        }
    }
}
/// The different types of certificates used in BeeGFS license generation and verification. At this
/// point, only Customer and Partner certificates are passed through protocol buffers.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CertType {
    Unspecified = 0,
    CaRoot = 1,
    CaIntermediate = 2,
    Partner = 3,
    Customer = 4,
    Temporary = 5,
}
impl CertType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CERT_TYPE_UNSPECIFIED",
            Self::CaRoot => "CERT_TYPE_CA_ROOT",
            Self::CaIntermediate => "CERT_TYPE_CA_INTERMEDIATE",
            Self::Partner => "CERT_TYPE_PARTNER",
            Self::Customer => "CERT_TYPE_CUSTOMER",
            Self::Temporary => "CERT_TYPE_TEMPORARY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CERT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CERT_TYPE_CA_ROOT" => Some(Self::CaRoot),
            "CERT_TYPE_CA_INTERMEDIATE" => Some(Self::CaIntermediate),
            "CERT_TYPE_PARTNER" => Some(Self::Partner),
            "CERT_TYPE_CUSTOMER" => Some(Self::Customer),
            "CERT_TYPE_TEMPORARY" => Some(Self::Temporary),
            _ => None,
        }
    }
}
